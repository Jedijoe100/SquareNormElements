Function: addpseudoprimes
Section: number_theoretical
C-Name: addpseudoprimes
Prototype: DG
Help: addpseudoprimes({x=[]}): add (pseudo-)primes in the vector x to the
 prime table to be used in trial division. x may also be a single integer.
 Composite "primes" are allowed; in fact, if the numbers are known to be
 prime, you should use addprimes() instead. List the current extra
 (pseudo-)primes if x is omitted.
Doc: adds the integers contained in the vector $x$ (or the single integer
 $x$) to a special table of ``user-defined pseudoprimes'', and returns that
 table. Whenever \kbd{factor} is subsequently called, it will trial divide by
 the elements in this table. Note that the arithmetic functions in the narrow
 sense, like \teb{eulerphi}, do \emph{not} use this extra table; only factor
 will.

 If $x$ is empty or omitted, just returns the current list of extra
 pseudoprimes.

 The entries in $x$ must be greater than $1$, and composite numbers are
 allowed. In fact, if the entries are proven primes, you should rather use
 \tet{addprimes}: all arithmetic functions will be able to use your primes,
 then, and not only factor.

 The use case is as follows: we have some composite numbers, which the
 function $\kbd{factor}(x,0)$ was not able to factor. They are now known to
 the factoring engine, and allow to significantly speed up some internal
 factorizations. Of course the ``primes'' produced in the factorization need
 not be genuine primes. The program goes on performing modular arithmetic : in
 case the message ``impossible inverse modulo $\langle$\var{some
 INTMOD}$\rangle$'' shows up afterwards, you have just stumbled over a
 non-trivial factor. This trick is used intensively by \tet{nfdisc}, for
 instance (due to Buchmann-Lenstra in this case).

 To remove (pseudo)primes from the list use \kbd{removepseudoprimes}.
