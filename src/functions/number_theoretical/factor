Function: factor
Section: number_theoretical
C-Name: factor0
Prototype: GD-1,L,
Help: factor(x,{lim}): factorization of x. lim is optional and can be set
 whenever x is of (possibly recursive) rational type. If lim is set return
 partial factorization, using primes up to lim (up to primelimit if lim=0).
Description:
 (int, ?-1):vec        Z_factor($1)
 (gen, ?-1):vec        factor($1)
 (int, small):vec      Z_factor_limit($1, $2)
 (gen, small):vec      factor0($1, $2)
Doc: general factorization function, where $x$ is a 
 rational (including integers), a complex number with rational
 real and imaginary parts, or a rational function (including polynomials).
 The result is a two-column matrix: the first contains the irreducibles
 dividing $x$ (rational or gaussian primes, irreducible polynomials),
 and the second the exponents. By convention, $0$ is factored as $0^1$.

 \misctitle{$\Q$ and $\Q(i)$.}
 The rational or gaussian primes are in fact \var{pseudoprimes}
 (see \kbd{ispseudoprime}), a priori not rigorously proven primes. In fact,
 any factor which is $\leq 10^{15}$ (whose norm is $\leq 10^{15}$ for an
 irrational gaussian prime) is a genuine prime. Use
 \kbd{isprime} to prove primality of other factors, as in
 \bprog
 fa = factor(2^2^7 +1)
 isprime( fa[,1] )
 @eprog\noindent
 Another possibility is to set the global default \tet{factor_proven}, which
 will perform a rigorous primality proof for each pseudoprime factor.

 An argument \var{lim} can be added, meaning that we look only for prime
 factors $p < \var{lim}$, or up to \kbd{primelimit}, whichever is lowest
 (except when $\var{lim}=0$ where the effect is identical to setting
 $\var{lim}=\kbd{primelimit}$). In this case, the remaining part may actually
 be a proven composite! See \tet{factorint} for more information about the
 algorithms used.

 \misctitle{Rational functions.}
 The polynomials or rational functions to be factored must have scalar
 coefficients. In particular PARI does not know how to factor
 \emph{multivariate} polynomials. See \tet{factormod} and \tet{factorff} for
 the algorithms used over finite fields, \tet{factornf} for the algorithms
 over number fields. Over $\Q$, \idx{van Hoeij}'s method is used, which is
 able to cope with hundreds of modular factors.

 The routine guesses a sensible ring over which you want to factor: the
 smallest ring containing all coefficients, taking into account quotient
 structures induced by \typ{INTMOD}s and \typ{POLMOD}s (e.g.~if a coefficient
 in $\Z/n\Z$ is known, all rational numbers encountered are first mapped to
 $\Z/n\Z$; different moduli will produce an error).
 Note that factorization of polynomials is done up to
 multiplication by a constant. In particular, the factors of rational
 polynomials will have integer coefficients, and the content of a polynomial
 or rational function is discarded and not included in the factorization. If
 needed, you can always ask for the content explicitly:

 \bprog
 ? factor(t^2 + 5/2*t + 1)
 %1 =
 [2*t + 1 1]

 [t + 2 1]

 ? content(t^2 + 5/2*t + 1)
 %2 = 1/2
 @eprog\noindent
 See also \tet{nffactor}.
Variant: Also available are \fun{GEN}{factor}{GEN x} and
 \fun{GEN}{boundfact}{GEN x, long lim}
