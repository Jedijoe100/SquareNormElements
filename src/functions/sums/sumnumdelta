Function: sumnumdelta
Section: sums
C-Name: sumnumdelta0
Prototype: V=GEDGp
Help: sumnumdelta(n=a,expr,{tab}): numerical summation of expr from
 n = a to +infinity using Euler-MacLaurin summation. Assume that expr
 corresponds to a series with positive terms and is a C^oo function; a
 must be an integer, and tab, if given, is the output of sumnumdeltainit.
Wrapper: (,G)
Description:
  (gen,gen,?gen):gen:prec sumnumdelta(${2 cookie}, ${2 wrapper}, $1, $3, prec)
Doc: numerical summation of \var{expr}, the variable $n$ taking values
 from $a$ to $+\infty$, where \var{expr} is assumed to have positive
 values and is a $C^\infty$ function; \kbd{a} must be an integer and
 \kbd{tab}, if given, is the output of \kbd{sumnumdeltainit}. The latter
 precomputes abcissas and weights (speeding up \kbd{sumnumdelta} by a
 rough factor 2 when \var{expr} is easy to evaluate); it also allows to specify
 the behaviour at infinity via \kbd{sumdeltainit([+oo, asymp])}.

 The function $f$ is evaluated at (a little less than) $D$ real arguments,
 where $D \approx \kbd{realprecision} \log(10)$.

 By default, the function assumes that \var{expr} decreases slowly at infinity,
 but at least like $O(n^{-2})$. If the function decreases like $n^{\alpha}$
 for some $-2 < \alpha < -1$, then it must be indicated via
 \bprog
   tab = sumnumdeltainit([+oo, alpha]); /* alpha < 0 slow decrease */
 @eprog\noindent otherwise loss of accuracy is expected.
 If the functions decreases quickly, like $\exp(-\alpha n)$ for some
 $\alpha > 0$, then it must be indicated via
 \bprog
   tab = sumnumdeltainit([+oo, alpha]); /* alpha  > 0 exponential decrease */
 @eprog\noindent otherwise exponent overflow will occur.
 \bprog
 ? sumnumdelta(n=1,2^-n)
  ***   at top-level: sumnumdelta(n=1,2^-n)
  ***                                  ^----
  *** _^_: overflow in expo().
 \bprog
 ? tab = sumnumdeltainit([+oo,log(2)]); \
   sumnumdelta(n=1,2^-n, tab)
 %1 = 1.000[...]
 @eprog

 As a shortcut, one can also input
 \bprog
   sumnumdelta(n = [a, asymp], f)
 @eprog\noindent
   tab = sumnumdeltainit(asymp);
   sumnumdelta(n = a, f, tab)
 @eprog

 \bprog
 ? \p200
 ? sumnumdelta(n = 1, n^(-2)) - zeta(2) \\ accurate, fast
 time = 200 ms.
 %1 = -2.376364457868949779 E-212
 ? sumpos(n = 1, n^(-2)) - zeta(2)  \\ even faster
 time = 96 ms.
 %2 = 0.E-211
 ? sumpos(n=1,n^(-4/3)) - zeta(4/3)   \\ now much slower
 time = 13,045 ms.
 %3 = -9.980730723049589073 E-210
 ? sumnumdelta(n=1,n^(-4/3)) - zeta(4/3)  \\ fast, inaccurate
 time = 365 ms.
 %4 = -9.85[...]E-85
 ? sumnumdelta(n=[1,-4/3],n^(-4/3)) - zeta(4/3) \\ decrease rate. Now accurate
 time = 416 ms.
 %5 = -4.134874156691972616 E-210

 ? tab = sumnumdeltainit([+oo,-4/3]);
 time = 196 ms.
 ? sumnumdelta(n=1, n^(-4/3), tab) - zeta(4/3) \\ faster with precomputations
 time = 216 ms.
 %5 = -4.134874156691972616 E-210
 ? sumnumdelta(n=1,-log(n)*n^(-4/3), tab) - zeta'(4/3)
 time = 321 ms.
 %7 = 7.224147951921607329 E-210
 @eprog

 Note that in the case of slow decrease ($\alpha < 0$), the exact
 decrease rate must be indicated, while in the case of exponential decrease,
 a rough value will do. In fact, for exponentially decreasing functions,
 \kbd{sumnum} is given for completeness and comparison purposes only: one
 of \kbd{suminf} or \kbd{sumpos} should always be preferred.
 \bprog
 ? sumnumdelta(n=[1, 1], 2^-n) \\ pretend we decrease as exp(-n)
 time = 240 ms.
 %8 = 1.000[...] \\ perfect
 ? sumpos(n=1, 2^-n)
 %9 = 1.000[...] \\ perfect and instantaneous
 @eprog\noindent
