Function: bitprecision
Section: conversions
C-Name: bitprecision0
Prototype: GD0,L,
Help: bitprecision(x,{n}): if n is present, return x at precision n bits. If n
 is omitted, return real precision of object x in bits.

Doc: the function has two different behaviors according to whether $n$ is
 present or not. If $n$ is missing, the function returns the (floating
 point) precision in bits of the PARI object $x$. If $x$ is an exact object,
 the largest single precision integer is returned.
 \bprog
 ? bitprecision(exp(1e-100))
 %1 = 512                 \\ 512 bits
 ? bitprecision( [ exp(1e-100), 0.5 ] )
 %2 = 128                 \\ minimal accuracy among components
 ? bitprecision(2 + x)
 %3 = 9223372036854775807 \\ exact object
 @eprog\noindent
 The return value for exact objects is meaningless since it is not even the
 same on 32 and 64-bit machines. The proper way to test whether an object is
 exact is
 \bprog
 ? isexact(x) = (precision(x) == precision(0));
 @eprog

 If $n$ is present, the function creates a new object equal to $x$ with the
 new bit-precision roughly $n$. In fact, the smallest multiple of 64
 (resp.~32 on a 32-bit machine) larger than $n$.

 For exact types, no change. For $x$ a vector or a matrix, the operation is
 done componentwise. For real $x$, $n$ is the number of desired significant
 \emph{bits}. If $n$ is smaller than the precision of $x$, $x$ is truncated,
 otherwise $x$ is extended with zeros.

 \bprog
 ? bitprecision(Pi, 10)    \\ actually 64 bits ~ 19 decimal digits
 %1 = 3.141592653589793239
 ? bitprecision(1 + O(x), 10)
 %2 = 1 + O(x^10)
 @eprog\noindent
