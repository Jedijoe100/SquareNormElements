Function: iferr
Section: programming/control
C-Name: iferrpari
Prototype: EVDEDE
Help: iferr(seq1,E,{seq2},{seq3}): evaluates the expression sequence seq1. if
 an error occurs, seq2 is evaluated with the formal parameter E set to the
 error data, otherwise seq3 is evaluated. The arguments seq2 and seq3 are
 optional, and if seq3 is omitted, the preceding comma can be omitted also.
Doc: evaluates the expression sequence \var{seq1}. if an error occurs,
 \var{seq2} is evaluated with the formal parameter \var{E} set to the error
 data, otherwise \var{seq3} is evaluated. The arguments \var{seq2} and
 \var{seq3} are optional, and if \var{seq3} is omitted, the preceding comma can
 be omitted also.
 The error type is given by \kbd{errname(E)}, and other data can be accessed using
 the \tet{component} function.
 The code \var{seq2} should check whether the error is the one expected. In the negative
 the error can be rethrown using \tet{error(E)} (and eventually caught by an higher
 \kbd{iferr} instance).
 The following uses \kbd{iferr} to implement Lenstra ECM factoring method:
 \bprog
 ? ecm(N,B,t)=
   {
     for(a=1,t,
       iferr(ellpow(ellinit([a,1]*Mod(1,N)),[0,1]*Mod(1,N),B),
            err,if(errname(err)=="invmoder",
                  return(gcd(lift(component(err,1)),N)),
                  error(err))));
   }
 ? ecm(2^101-1,1000!,100)
 %2 = 7432339208719
 @eprog
 The return value of \kbd{iferr} itself is, if an error occurs, the value of \var{seq2},
 otherwise it is the value of \var{seq3} unless it is omitted, in which case it returns the
 value of \var{seq1} itself.
