Function: _iferr_CATCH
Class: gp2c_internal
Description:
  (0)               pari_CATCH(CATCH_ALL)
  (small)           pari_CATCH2(__iferr_old$1, CATCH_ALL)
  (0,errtyp)        pari_CATCH($2)
  (small,errtyp)    pari_CATCH2(__iferr_old$1, $2)

Function: _iferr_ENDCATCH
Class: gp2c_internal
Description:
  (0)        pari_ENDCATCH
  (small)    pari_ENDCATCH2(__iferr_old$1)

Function: _iferr_CATCH_reset
Class: gp2c_internal
Description:
  (0):void      pari_CATCH_reset()
  (small):void  pari_CATCH2_reset(__iferr_old$1)

Function: _iferr_error
Class: gp2c_internal
Description:
  ():error pari_err_last()

Function: iferr
Section: programming/control
C-Name: iferrpari
Prototype: EVE
Help: iferr(seq1,E,seq2): evaluates the expression sequence seq1. If
 an error occurs, seq2 is evaluated with the formal parameter E set to the
 error data.
Doc: evaluates the expression sequence \var{seq1}. If an error occurs,
 \var{seq2} is evaluated with the formal parameter \var{E} set to the error
 data. The error type is given by \kbd{errname(E)}, and other data can be
 accessed using the \tet{component} function (see the documentation of
 \tet{iferrname}). The code \var{seq2} should check whether the error is
 the one expected. In the negative the error can be rethrown using
 \tet{error(E)} (and possibly caught by an higher \kbd{iferr} instance). The
 following uses \kbd{iferr} to implement Lenstra's ECM factoring method
 (however see \tet{iferrname} for a simpler implementation).
 \bprog
 ? ecm(N, B = 1000!, nb = 100)=
   { my(T);
     for(a = 1, nb,
       iferr(ellmul(ellinit([a,1]*Mod(1,N)), [0,1]*Mod(1,N), B),
         E, if(errname(E)=="e_INV" && type( T=component(E,2) ) == "t_INTMOD",
              return(gcd(lift(T),N)),
              error(E))));
   }
 ? ecm(2^101-1)
 %2 = 7432339208719
 @eprog
 The return value of \kbd{iferr} itself is the value of \var{seq2} if an
 error occurs, and the value of \var{seq1} otherwise.
