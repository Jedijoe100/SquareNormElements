Function: nfbasis
Section: number_fields
C-Name: nfbasis_gp
Prototype: GDGDG
Help: nfbasis(T,{listP}): integral basis of the field Q[a], where a is
 a root of the polynomial T, using the round 4 algorithm. The second argument
 listP, if present, is a list of primes (useful if one wants only an order
 maximal at certain primes only) or a prime bound.
Doc:
 Let $T(X)$ be an irreducible polynomial with integral coefficients. This
 function returns an \idx{integral basis} of the number field defined by $T$,
 that is a $\Z$-basis of its maximal order. The basis elements are given as
 elements in $\Q[X]/(T)$:
 \bprog
 ? nfbasis(x^2 + 1)
 %1 = [1, x]
 @eprog
 This function uses a modified version of the \idx{round 4} algorithm,
 due to David \idx{Ford}, Sebastian \idx{Pauli} and Xavier \idx{Roblot}.

 If \var{listP} is present it must be a factorization matrix, a vector of
 pairwise coprime integers or a single integer:

 \item Vector: the function assumes that it contains distinct \emph{prime}
 numbers.

 \item Matrix: the function assumes that it is a two-column matrix of a
 (partial) factorization of $D$; namely the first column contains
 \emph{primes} and the second one the valuation of $D$ at each of these
 primes.

 \item Integer $B$: this is replaced by the vector of primes up to $B$. Note
 that the function will use at least $O(B)$ time: a small value, about
 $10^5$, should be enough for most applications. Values larger than $2^{32}$
 are not supported.

 In all these cases, the integers may or may not divide the discriminant $D$
 of $T$. The function then returns a $\Z$-basis of an order whose index is
 not divisible by any of these prime numbers.
 This is useful if only a local integral basis for some small
 set of places is desired, but the result is actually a global integral basis
 if all prime divisors of the \emph{field} discriminant are included! This
 allows to create an \kbd{nf} structure associated to the number
 field $K = \Q[X]/(T)$, when the discriminant of $T$ cannot be factored
 completely, whereas the prime divisors of $\disc K$ are known. Let \var{listP}
 contain such primes:
 \bprog
 ? b = nfbasis(T, listP);
 ? nf = nfinit([T, b]);
 @eprog

 Of course, if \var{listP} contains a single prime number $p$,
 the function returns a local integral basis for $\Z_p[X]/(T)$:
 \bprog
 ? nfbasis(x^2+x-1001)
 %1 = [1, 1/3*x - 1/3]
 ? nfbasis(x^2+x-1001, [2])
 %2 = [1, x]
 @eprog

 \misctitle{The Buchmann-Lenstra algorithm}
 It is also allowed to include \emph{composite} numbers instead of primes,
 the result will still be a correct integral basis if the field discriminant
 factors completely over the actual primes in the list. Adding a
 composite $C$ \emph{dividing} $D$ may help because when we consider $C$
 as a prime and run
 the algorithm, two good things can happen: either we succed in proving that
 no prime dividing $C$ can divide the index (without actually needing to find
 those primes), or we succeed in factoring $C$ and go on with the refined
 factorization. (Note that including a $D$ not dividing $C$ is useless.)
 It may also happen that neither happen, and the computed basis
 need not generate the maximal order:
 \bprog
 ? B = 10^7;
 ? P = factor(poldisc(T), B)[,1]; \\ primes <= B dividing D + cofactor
 ? nf = nfinit( [T, nfbasis(T, B)] );
 ? check = factor(nf.disc, B); check[-1..-1,1] <= B
 @eprog The nf structure is correct if $\kbd{check} = 1$,
 i.e. if the field discriminant factors completely over the primes
 less than $B$.

 \synt{nfbasis}{GEN T, GEN *d, GEN listP = NULL}, which returns the order
 basis, and where \kbd{*d} receives the order discriminant.
