/* $Id$

Copyright (C) 2000  The PARI group.

This file is part of the PARI/GP package.

PARI/GP is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation. It is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY WHATSOEVER.

Check the License for details. You should have received a copy of it, along
with the package; see the file 'COPYING'. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */

#include "pari.h"
extern GEN hnf0(GEN x, long r);
void push_val(entree *ep, GEN a);
void pop_val(entree *ep);

/* SUBGROUPS
 * Assume: G = Gp x I, with Gp a p-group and (|I|,p)=1, and I small.
 * Compute subgroups of I by recursive calls
 * Loop through subgroups Hp of Gp using Birkhoff's algorithm.
 * If (I is non trivial)
 *   lift Hp to G (mul by exponent of I)
 *   for each subgp of I, lift it to G (mult by exponent of Gp)
 *   consider the group generated by the two subgroups (concat)
 */
typedef struct slist {
  struct slist *next;
  long *data;
} slist;

typedef struct subgp_iter {
  long *powerlist, *mmu, *lam, *c, *maxc, *a, *maxa, **g, **maxg;
  GEN **H, subq, subqpart, hnfgroup;
  GEN BINMAT, indexbound, cyc, bound;
  long countsub, count, expoI, nbsub;
  long *available, lsubq, lsubqpart;
  char *gpch;
  entree *ep;
  void(*fun)(struct subgp_iter *, GEN);
  slist *sublist;
} subgp_iter; 

void 
printtyp(long *typ)
{
  long i;
  for (i=1; i<=typ[0]; i++) fprintferr(" %ld ",typ[i]);
  fprintferr("\n");
}

/* compute conjugate partition of typ */
static long*
conjugate(long *typ)
{
  long *t, i, k = typ[0], l, last;

  if (!k) { t = new_chunk(1); t[0]=0; return t; }
  l = typ[1]; t = new_chunk(l+2);
  t[1] = k; last = k;
  for (i=2; i<=l; i++)
  {
    while (typ[last] < i) last--;
    t[i] = last;
  }
  t[i] = 0; t[0] = l;
  return t;
}

static void
std_fun(subgp_iter *T, GEN x)
{
  T->ep->value = (void*)x;
  lisseq(T->gpch); T->countsub++;
}

static void
addcell(subgp_iter *T, GEN H)
{
  long *pt,i,j, k = 0, n = lg(H)-1;
  slist *cell = (slist*) gpmalloc(sizeof(slist) + n*(n+1)/2 * sizeof(long));

  T->sublist->next = cell; cell->data = pt = (long*) (cell + 1);
  for (j=1; j<=n; j++)
    for(i=1; i<=j; i++) pt[k++] = itos(gcoeff(H,i,j));
  T->sublist = cell;
}

static void
list_fun(subgp_iter *T, GEN x)
{
  addcell(T, hnf(concatsp(T->hnfgroup,x))); T->countsub++;
}

/* treat subgroup Hp (not in HNF, T->fun should do it if desired) */
static void
treatsub(subgp_iter *T, GEN H)
{
  long i;
  if (!T->subq) T->fun(T, H);
  else
  { /* not T->a p group, add the trivial part */
    GEN Hp = gmulsg(T->expoI, H); /* lift T->H to G */
    for (i=1; i<T->lsubqpart; i++)
      T->fun(T, concatsp(Hp, (GEN)T->subqpart[i]));
  }
}

/* assume t>0 and l>1 */
static void
dogroup(subgp_iter *T)
{
  ulong av = avma, av1;
  long e,i,j,k,r,n,t2,ind, t = T->mmu[0], l = T->lam[0];

  t2 = (l==t)? t-1: t;
  n = t2 * l - (t2*(t2+1))/2; /* number of gamma_ij */
  for (i=1, r=t+1; ; i++)
  {
    if (T->available[i]) T->c[r++] = i;
    if (r > l) break;
  }
  if (DEBUGLEVEL>2) { fprintferr("    column selection:"); printtyp(T->c); }
  /* a/g and maxa/maxg access the same data indexed differently */
  for (ind=0,i=1; i<=t; ind+=(l-i),i++)
  {
    T->maxg[i] = T->maxa + (ind - (i+1)); /* only access T->maxg[i][i+1..l] */
    T->g[i] = T->a + (ind - (i+1));
    for (r=i+1; r<=l; r++)
      if (T->c[r] < T->c[i])
        T->maxg[i][r] = T->powerlist[T->mmu[i]-T->mmu[r]-1];
      else if (T->lam[T->c[r]] < T->mmu[i])
        T->maxg[i][r] = T->powerlist[T->lam[T->c[r]]-T->mmu[r]];
      else
        T->maxg[i][r] = T->powerlist[T->mmu[i]-T->mmu[r]];
  }
  av1 = avma; T->a[n-1]=0; for (i=0; i<n-1; i++) T->a[i]=1; 
  for(;;)
  {
    T->a[n-1]++;
    if (T->a[n-1] > T->maxa[n-1])
    {
      j=n-2; while (j>=0 && T->a[j]==T->maxa[j]) j--;
      if (j < 0) { avma = av; return; }

      T->a[j]++; for (k=j+1; k<n; k++) T->a[k]=1;
    }
    for (i=1; i<=t; i++)
    {
      for (r=1; r<i; r++) affsi(0, T->H[i][T->c[r]]);
      affsi(T->powerlist[T->lam[T->c[r]] - T->mmu[r]], T->H[r][T->c[r]]);
      for (r=i+1; r<=l; r++)
      {
        if (T->c[r] < T->c[i]) 
          e = T->g[i][r] * T->powerlist[T->lam[T->c[r]] - T->mmu[i]+1];
        else
          if (T->lam[T->c[r]] < T->mmu[i]) e = T->g[i][r];
          else e = T->g[i][r] * T->powerlist[T->lam[T->c[r]] - T->mmu[i]];
        affsi(e, T->H[i][T->c[r]]);
      }
    }
    treatsub(T, (GEN)T->H); avma = av1;
  }
}

/* T->c[1],...,T->c[r-1] filled */
static void
loop(subgp_iter *T, long r)
{
  long j;

  if (r > T->mmu[0]) { dogroup(T); return; }

  if (r!=1 && (T->mmu[r-1] == T->mmu[r])) j = T->c[r-1]+1; else j = 1;
  for (  ; j<=T->maxc[r]; j++)
    if (T->available[j])
    {
      T->c[r] = j;  T->available[j] = 0;
      loop(T, r+1); T->available[j] = 1;
    }
}

static void
dopsubtyp(subgp_iter *T)
{
  ulong av = avma;
  long i,r, l = T->lam[0], t = T->mmu[0]; 

  if (!t)
  {
    GEN p1 = cgetg(2,t_MAT);
    p1[1] = (long)zerocol(l); 
    treatsub(T, p1); avma = av; return;
  }
  if (l==1) /* imply t = 1 */
  {
    GEN p1 = gtomat(stoi(T->powerlist[T->lam[1]-T->mmu[1]]));
    treatsub(T, p1); avma = av; return;
  }
  T->c = new_chunk(l+1); T->c[0] = l;
  T->maxc = new_chunk(l+1);
  T->available = new_chunk(l+1);
  T->a  = new_chunk(l*(t+1));
  T->maxa=new_chunk(l*(t+1));
  T->g = (long**)new_chunk(t+1);
  T->maxg = (long**)new_chunk(t+1);

  if (DEBUGLEVEL) { fprintferr("  subgroup:"); printtyp(T->mmu); }
  for (i=1; i<=t; i++)
  {
    for (r=1; r<=l; r++)
      if (T->mmu[i] > T->lam[r]) break;
    T->maxc[i] = r-1;
  }
  T->H = (GEN**)cgetg(t+1, t_MAT);
  for (i=1; i<=t; i++)
  {
    T->H[i] = (GEN*)cgetg(l+1, t_COL);
    for (r=1; r<=l; r++) T->H[i][r] = cgeti(3);
  }
  for (i=1; i<=l; i++) T->available[i]=1;
  for (i=1; i<=t; i++) T->c[i]=0;
  /* go through all column selections */
  loop(T, 1); avma = av; return;
}

static long
weight(long *typ)
{
  long i,w = 0;
  for (i=1; i<=typ[0]; i++) w += typ[i];
  return w;
}

static void
dopsub(subgp_iter *T, long p, long *gtyp, GEN indexsubq)
{
  long w,i,j,k,n, wg = 0, wmin = 0;

  if (DEBUGLEVEL) { fprintferr("\ngroup:"); printtyp(gtyp); }
  T->count = 0;
  if (T->indexbound)
  {
    wg = weight(gtyp);
    wmin = (long) (wg - (log(gtodouble(T->indexbound)) / log((double)p)));
    if (cmpii(gpuigs(stoi(p), wg - wmin), T->indexbound) > 0) wmin++;
  }
  T->lam = gtyp; n = T->lam[0]; T->mmu = new_chunk(n+1);
  T->mmu[1] = -1; for (i=2; i<=n; i++) T->mmu[i]=0;
  for(;;) /* go through all vectors mu_{i+1} <= mu_i <= lam_i */
  {
    T->mmu[1]++;
    if (T->mmu[1] > T->lam[1])
    {
      for (j=2; j<=n; j++)
        if (T->mmu[j] < T->lam[j] && T->mmu[j] < T->mmu[j-1]) break;
      if (j > n) return;

      T->mmu[j]++; for (k=1; k<j; k++) T->mmu[k]=T->mmu[j];
    }
    for (j=1; j<=n; j++)
      if (!T->mmu[j]) break;
    T->mmu[0] = j-1; w = weight(T->mmu);
    if (w >= wmin)
    { 
      GEN p1 = gun;

      if (T->subq) /* G not T->a p-group */
      {
        if (T->indexbound)
        {
          GEN indexH = gpuigs(stoi(p), wg - w);
          GEN bound = divii(T->indexbound, indexH);
          T->subqpart = cgetg(T->lsubq, t_VEC);
          T->lsubqpart = 1;
          for (i=1; i<T->lsubq; i++)
            if (cmpii((GEN)indexsubq[i], bound) <= 0)
              T->subqpart[T->lsubqpart++] = T->subq[i];
        }
        else { T->subqpart = T->subq; T->lsubqpart = T->lsubq; }
      }
      if (DEBUGLEVEL)
      {
        long *lp = conjugate(T->lam);
        long *mp = conjugate(T->mmu);

        if (DEBUGLEVEL > 3)
        {
          fprintferr("    lambda = "); printtyp(T->lam);
          fprintferr("    lambda'= "); printtyp(lp);
          fprintferr("    mu = "); printtyp(T->mmu);
          fprintferr("    mu'= "); printtyp(mp);
        }
        for (j=1; j<=mp[0]; j++)
        {
          p1 = mulii(p1, gpuigs(stoi(p), mp[j+1]*(lp[j]-mp[j])));
          p1 = mulii(p1, gcoeff(T->BINMAT, lp[j]-mp[j+1]+1, mp[j]-mp[j+1]+1));
        }
        fprintferr("  alpha_lambda(mu,p) = %Z\n",p1);
      }
      T->countsub = 0;

      dopsubtyp(T);

      T->count += T->countsub;
      if (DEBUGLEVEL)
      {
        fprintferr("  countsub = %ld\n", T->countsub);
        msgtimer("for this type");
        if (T->subq) p1 = mulis(p1,T->lsubqpart-1);
        if (cmpis(p1,T->countsub))
        {
          fprintferr("  alpha = %Z\n",p1);
          err(bugparier,"forsubgroup (alpha != countsub)");
        }
      }
    }
  }
}

static GEN
expand_sub(GEN x, long n)
{
  long i,j, m = lg(x);
  GEN p = idmat(n-1), q,c;

  for (i=1; i<m; i++)
  {
    q = (GEN)p[i]; c = (GEN)x[i];
    for (j=1; j<m; j++) q[j] = c[j];
    for (   ; j<n; j++) q[j] = zero;
  }
  return p;
}

extern GEN matqpascal(long n, GEN q);
static GEN subgrouplist_i(GEN cyc, GEN bound, long expoI);

static long
subgroup_engine(subgp_iter *T)
{
  ulong av = avma;
  GEN gtyp,fa,junk,primlist,p,listgtyp,indexsubq = NULL;
  GEN cyc = T->cyc, bound = T->bound;
  long i,j,k,imax,nbprim, n = lg(cyc);
  
  if (typ(cyc) != t_VEC) 
  {
    if (typ(cyc) != t_MAT) err(typeer,"forsubgroup");
    cyc = mattodiagonal(cyc);
  }
  for (i=1; i<n-1; i++)
    if (!divise((GEN)cyc[i], (GEN)cyc[i+1]))
      err(talker,"not T->a group in forsubgroup");
  if (n == 1) { T->fun(T, cyc); return 1; }
  if (!signe(cyc[1]))
    err(talker,"infinite group in forsubgroup");
  if (DEBUGLEVEL) timer2();
  T->indexbound = bound;
  fa = factor((GEN)cyc[1]); primlist = (GEN)fa[1];
  nbprim = lg(primlist);
  listgtyp = new_chunk(n); imax = k = 0;
  for (i=1; i<nbprim; i++)
  {
    gtyp = new_chunk(n); p = (GEN)primlist[i];
    for (j=1; j<n; j++)
    {
      gtyp[j] = pvaluation((GEN)cyc[j], p, &junk);
      if (!gtyp[j]) break;
    }
    j--; gtyp[0] = j;
    if (j > k) { k = j; imax = i; }
    listgtyp[i] = (long)gtyp;
  }
  gtyp = (GEN)listgtyp[imax]; p = (GEN)primlist[imax];
  k = gtyp[1];
  T->powerlist = new_chunk(k+1); T->powerlist[0] = 1;
  T->powerlist[1] = itos(p);
  for (j=1; j<=k; j++) T->powerlist[j] = T->powerlist[1] * T->powerlist[j-1];

  if (DEBUGLEVEL) T->BINMAT = matqpascal(gtyp[0]+1, p);
  if (nbprim == 2) T->subq = NULL;
  else
  { /* not a p-group */
    GEN cyc2 = dummycopy(cyc);
    for (i=1; i<n; i++)
    {
      cyc2[i] = ldivis((GEN)cyc2[i], T->powerlist[gtyp[i]]);
      if (gcmp1((GEN)cyc2[i])) break;
    }
    setlg(cyc2, i);
    if (is_bigint(cyc[1]))
      err(impl,"subgrouplist for large cyclic factors");
    T->expoI = itos((GEN)cyc2[1]);

    T->subq = subgrouplist_i(cyc2, bound, T->expoI);

    T->lsubq = lg(T->subq);
    for (i=1; i<T->lsubq; i++) 
      T->subq[i] = (long)expand_sub((GEN)T->subq[i], n);
    if (T->indexbound)
    {
      indexsubq = cgetg(T->lsubq,t_VEC);
      for (i=1; i<T->lsubq; i++)
        indexsubq[i] = (long)dethnf_i((GEN)T->subq[i]);
    }
    /* lift subgroups of I to G */
    for (i=1; i<T->lsubq; i++) 
      T->subq[i] = lmulsg(T->powerlist[k],(GEN)T->subq[i]);
    if (DEBUGLEVEL>2)
    {
      fprintferr("(lifted) subgp of prime to %Z part:\n",p);
      outbeaut(T->subq);
    }
  }
  dopsub(T, T->powerlist[1],gtyp,indexsubq); 
  if (DEBUGLEVEL) fprintferr("nb subgroup = %ld\n",T->count);
  avma = av; return T->count;
}

static GEN
get_snf(GEN x, long *N)
{
  GEN cyc;
  long n;
  switch(typ(x))
  {
    case t_MAT:
      if (!isdiagonal(x)) return NULL;
      cyc = mattodiagonal_i(x); break;
    case t_VEC: if (lg(x) == 4 && typ(x[2]) == t_VEC) x = (GEN)x[2];
    case t_COL: cyc = dummycopy(x); break;
    default: return NULL;
  }
  *N = lg(cyc)-1;
  for (n = *N; n > 0; n--) /* take care of trailing 1s */
  {
    GEN c = (GEN)cyc[n];
    if (typ(c) != t_INT) return NULL;
    if (!gcmp1(c)) break;
  }
  setlg(cyc, n+1);
  for ( ; n > 0; n--)
  {
    GEN c = (GEN)cyc[n];
    if (typ(c) != t_INT) return NULL;
  }
  return cyc;
}

void
forsubgroup(entree *ep, GEN cyc, GEN bound, char *ch)
{
  subgp_iter T;
  long N;

  T.fun = &std_fun;
  cyc = get_snf(cyc,&N);
  if (!cyc) err(typeer,"forsubgroup");
  T.bound = bound;
  T.cyc = cyc;
  T.gpch = ch;
  T.ep = ep;
  push_val(ep, gzero);
  (void)subgroup_engine(&T);
  pop_val(ep);
}

static GEN
subgrouplist_i(GEN cyc, GEN bound, long expoI)
{
  ulong av = avma;
  subgp_iter T;
  slist *list; 
  long ii,i,j,k,nbsub,n,N;
  GEN z,H;

  T.sublist = list = (slist*) gpmalloc(sizeof(slist));
  T.fun = &list_fun;
  cyc = get_snf(cyc, &N);
  if (!cyc) err(typeer,"subgrouplist");
  n = lg(cyc)-1; /* not necessarily = N */
  T.hnfgroup = diagonal(cyc);
  T.cyc = cyc;
  T.bound = bound;
  T.expoI = expoI;

  nbsub = subgroup_engine(&T);

  avma = av;
  z = cgetg(nbsub+1,t_VEC); T.sublist = list;
  for (ii=1; ii<=nbsub; ii++)
  {
    list = T.sublist; T.sublist = list->next; free(list);
    H = cgetg(N+1,t_MAT); z[ii]=(long)H; k=0;
    for (j=1; j<=n; j++)
    {
      H[j] = lgetg(N+1, t_COL);
      for (i=1; i<=j; i++) coeff(H,i,j) = lstoi(T.sublist->data[k++]);
      for (   ; i<=N; i++) coeff(H,i,j) = zero;
    }
    for (   ; j<=N; j++)
    {
      H[j] = lgetg(N+1, t_COL);
      for (i=1; i<=N; i++) coeff(H,i,j) = (i==j)? un: zero;
    }
  }
  free(T.sublist);
  return z;
}

GEN
subgrouplist(GEN cyc, GEN bound)
{
  return subgrouplist_i(cyc,bound,-1);
}
