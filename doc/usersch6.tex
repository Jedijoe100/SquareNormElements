% $Id: usersch6.tex 10212 2008-05-30 23:21:35Z kb $
% Copyright (c) 2000  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{Technical Reference Guide for Algebraic Number Theory}

\section{General Number Fields}

\subsec{Number field types}

None of the following routines thoroughly check their intput: they
distinguish between \emph{bona fide} structures as output by PARI routines,
but designing perverse data will easily fool them. To give an example, a
square matrix will be interpreted as an ideal even though the $\Z$-module
generated by its columns may not be an $O_K$-module (i.e. the expensive
\kbd{nfisideal} routine will \emph{not} be called).

\fun{long}{nftyp}{GEN x}. Returns the type of number field structure stored in
\kbd{x}, \tet{typ_NF}, \tet{typ_BNF}, or \tet{typ_BNR}. Other answers
are possible, meaning \kbd{x} is not a number field structure.

\fun{GEN}{get_nf}{GEN x, long *t}. Extract an \var{nf} structure from
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{get_bnf}{GEN x, long *t}. Extract a \kbd{bnf} structure from
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{get_nfpol}{GEN x, GEN *nf} try to extract and \var{nf} structure
from \kbd{x}, and sets \kbd{*nf} to \kbd{NULL} (failure) or to the \var{nf}.
Returns the (monic, integral) polynomial defining the field.

\fun{GEN}{get_bnfpol}{GEN x, GEN *bnf, GEN *nf} try to extract a \var{bnf}
and an \var{nf} structure from \kbd{x}, and sets \kbd{*bnf}
and \kbd{*nf} to \kbd{NULL} (failure) or to the corresponding structure.
Returns the (monic, integral) polynomial defining the field.

\fun{GEN}{checknf}{GEN x} if an \var{nf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_nf} is often more flexible.

\fun{GEN}{checkbnf}{GEN x} if an \var{bnf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_bnf} is often more flexible.

\fun{void}{checkbnr}{GEN bnr} Raise an exception if the argument
is not a \var{bnr} structure.

\fun{void}{checkbnrgen}{GEN bnr} Raise an exception if the argument is not a
\var{bnr} structure, complete with explicit generators for the ray class group.

\fun{void}{checkrnf}{GEN rnf} Raise an exception if the argument is not an
\var{rnf} structure.

\fun{void}{checkbid}{GEN bid} Raise an exception if the argument is not a
\var{bid} structure.

\fun{GEN}{checkgal}{GEN x} if a \var{galoisinit} structure can be extracted
from \kbd{x}, return it; otherwise raise an exception.

\fun{void}{checksqmat}{GEN x, long N} check whether \kbd{x} is a square matrix
of dimension \kbd{N}. May be used to check for ideals if \kbd{N} is the field
degree.

\fun{void}{checkprid}{GEN bid} Raise an exception if the argument is not a
prime ideal structure.

\fun{void}{checkmodpr}{GEN modpr} Raise an exception if the argument is not a
 prime ideal structure.

\fun{GEN}{checknfelt_mod}{GEN nf, GEN x, char *s} Given an \var{nf} structure
\kbd{nf} and a \typ{POLMOD} \kbd{x}, return the associated polynomial
representative (shallow) if \kbd{x} and \kbd{nf} are compatible. Raise an
eception otherwise.

\fun{long}{idealtyp}{GEN *ideal, GEN *fa} The input is \kbd{ideal}, a pointer
to an ideal (or extended ideal), which is usually modified, \kbd{fa} being
set as a side-effect. Returns the type of the underlying ideal among
\tet{id_PRINCIPAL} (a number field element), \tet{id_PRIME} (a prime ideal)
\tet{id_MAT} (an ideal in matrix form).

If \kbd{ideal} pointed to an ideal, set \kbd{fa} to \kbd{NULL}, and
possibly simplify \kbd{ideal} (for instance the zero ideal is replaced by
\kbd{gen\_0}). If it pointed to an extended ideal, replace
\kbd{ideal} by the underlying ideal and set \kbd{fa} to the factorization
matrix component.

\subsec{Extracting info from a \kbd{nf} structure}

These function expect a true \var{nf} argument, e.g.~a \var{bnf} will not
work.

\fun{long}{nf_get_r1}{GEN nf} returns the number of real places $r_1$.

\fun{long}{nf_get_r2}{GEN nf} returns the number of complex places $r_2$.

\fun{void}{nf_get_sign}{GEN nf, long *r1, long *r2} sets $r_1$ and $r_2$
to the number of real and complex places respectively. Note that
$r_1+2r_2$ is the field degree.

\fun{GEN}{nf_get_roots}{GEN nf} returns the complex roots of the polynomial
defining the number fields: first the $r_1$ real roots (as \typ{REAL}s),
then the $r_2$ pairs of complex conjugates.

\fun{long}{nf_get_prec}{GEN nf} returns the precision (in words) to which the
\var{nf} was computed.

\fun{GEN}{nf_to_scalar_or_basis}{GEN nf, GEN x} let $x$ be a number field
element. If it is a rational scalar, i.e.~can be represented by a \typ{INT}
or \typ{FRAC}, return the latter. Otherwise returns its basis representation
(\tet{nfalgtobasis}). Shallow function.

\fun{GEN}{nf_to_scalar_or_alg}{GEN nf, GEN x} let $x$ be a number field
element. If it is a rational scalar, i.e.~can be represented by a \typ{INT}
or \typ{FRAC}, return the latter. Otherwise returns its lifted \typ{POLMOD}
representation (lifted \tet{nfbasistoalg}). Shallow function.

\fun{GEN}{RgX_to_nfX}{GEN nf, GEN x} let $x$ be a polynomial whose coefficients
are number field elements; apply \kbd{nf\_to\_scalar\_or\_basis} to each
coefficient and return the resulting new polynomial. Shallow function.

\subsec{Increasing accuracy}

\fun{GEN}{nfnewprec}{GEN x, long prec}. Raise an exception if \kbd{x}
is not a number field structure (\var{nf}, \var{bnf} or \var{bnr}).
Otherwise, sets its accuracy to \kbd{prec} and return the new structure.
This is mostly useful with \kbd{prec} larger than the accuracy to
which \kbd{x} was computed, but it is also possible to decrease the accuracy
of \kbd{x} (truncating relevant components, which may speed up later
computations). This routine may modify the original \kbd{x} (see below).

This routine is straighforward for \var{nf} structures, but for the
other ones, it requires all principal ideals corresponding to the \var{bnf}
relations in algebraic form (they are originally only available via floating
point approximations). This in turn requires many calls to
\kbd{bnfisprincipal}, which is often slow, and may fail if the initial
accuracy was too low. In this case, the routine will not actually fail but
recomputes a \var{bnf} from scratch!

Since this process may be very expensive, the corresponding data is cached
(as a \emph{clone}) in the \emph{original} \kbd{x} so that later precision
increases become very fast. In particular, the copy returned by
\kbd{nfnewprec} also contains this additional data.

\fun{GEN}{bnfnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts
a \var{bnf} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{bnrnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts a
\var{bnr} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{nfnewprec_shallow}{GEN nf, long prec}

\fun{GEN}{bnfnewprec_shallow}{GEN bnf, long prec}

\fun{GEN}{bnrnewprec_shallow}{GEN bnr, long prec} Shallow functions
underlying the above, except that the first argument must now have the
corresponding number field type. I.e. one cannot call
\kbd{nfnewprec\_shallow(nf, prec)} if \kbd{nf} is actually a \var{bnf}.

\subsec{Number field arithmetic}
The number field $K = \Q[X]/(T)$ is represented by an \kbd{nf} (or \kbd{bnf}
or \kbd{bnr} structure). An algebraic number belonging to $K$ is given as

\item a \typ{INT}, \typ{FRAC} or \typ{POL} (implicitly modulo $T$), or

\item a \typ{POLMOD} (modulo $T$), or

\item a \typ{COL}~\kbd{v} of dimension $N = [K:\Q]$, representing
the element in terms of the computed integral basis $(e_i)$, as
\bprog
  sum(i = 1, N, v[i] * nf.zk[i])
@eprog
The preferred forms are \typ{INT} and \typ{COL} of \typ{INT}. Routines can
handle denominators but it is much more efficient to remove  denominators
first (\tet{Q_remove_denom}) and take them into account at the end.

\misctitle{Safe routines.} The following routines do not assume that their
\kbd{nf} argument is a true \var{nf} (it can be any number field type, e.g.~a
\var{bnf}), and accept number field elements in all the above forms. They
return their result in \typ{COL} form.

\fun{GEN}{nfadd}{GEN nf, GEN x, GEN y} return $x+y$

\fun{GEN}{nfdiv}{GEN nf, GEN x, GEN y} return $x / y$

\fun{GEN}{nfinv}{GEN nf, GEN x} returns $x^{-1}$

\fun{GEN}{nfmul}{GEN nf,GEN x,GEN y} returns $xy$.

\fun{GEN}{nfpow}{GEN nf,GEN x,GEN k} returns $x^k$, $k$ is in $\Z$.

\fun{GEN}{nfsqr}{GEN nf,GEN x} returns $x^2$

\fun{long}{nfval}{GEN nf, GEN x, GEN pr} returns the valuation of $x$ at the
maximal ideal $\goth{p}$ associated to \kbd{pr}, in \kbd{idealprimedec} form.
Returns \kbd{LONG\_MAX} is $x$ is $0$.

The following three functions implement trivially functionnalities akin to
Euclidean division, for which we currently have no real use. Of course, even if
the number field is actually Euclidean, these do not in general implement a
true Euclidean division.

\fun{GEN}{nfdiveuc}{GEN nf, GEN a, GEN b} returns the algebraic integer
closest to $x / y$. Functionnally identical to \kbd{ground( nfdiv(nf,x,y) )}.

\fun{GEN}{nfdivrem}{GEN nf, GEN a, GEN b} returns the vector $[q,r]$, where
to 
\bprog
  q = nfdiveuc(nf, a,b);
  r = nfadd(nf, a,nfmul(nf,q,gneg(b)));    \\ or r = nfmod(nf,a,b);
@eprog

\fun{GEN}{nfmod}{GEN nf, GEN a, GEN b} returns $r$ such that
\bprog
  q = nfdiveuc(nf, a,b);
  r = nfadd(nf, a, nfmul(nf,q, gneg(b)));
@eprog

\misctitle{Unsafe routines.} The following routines assume that their \kbd{nf}
argument is a true \var{nf} (e.g.~a \var{bnf} is not allowed) and their
argument are restricted in various ways, see the precise description below.

\fun{GEN}{nfmuli}{GEN nf, GEN x, GEN y} returns $x\times y$ assuming
that both $x$ and $y$ are either \typ{INT}s or \kbd{ZV}s of the correct
dimension.

\fun{GEN}{nfsqri}{GEN nf, GEN x} returns $x^2$ assuming that $x$ is a \typ{INT}
or a \kbd{ZV} of the correct dimension.

\fun{GEN}{nfC_nf_mul}{GEN nf, GEN v, GEN x} given a \typ{VEC} or \typ{COL}
$v$ of elements of $K$ in \typ{INT}, \typ{FRAC} or \typ{COL} form, multiply
it by the element $x$ (arbitrary form). This is faster than multiplying
coordinatewise since pre-computations related to $x$ (computing the
multiplication table) are done only once. The components of the result 
are in most cases \typ{COL}s but are allowed to be \typ{INT}s or \typ{FRAC}s.

\fun{GEN}{zk_multable}{GEN nf, GEN x} given a \kbd{ZC} $x$ (implicitly
representing an algebraic integer), returns the \kbd{ZM} giving the
multiplication table by $x$. Shallow function (the first column of the result
points to the same data as $x$).

\fun{GEN}{zk_scalar_or_multable}{GEN nf, GEN x} given a \typ{INT} or \kbd{ZC}
$x$, returns a \typ{INT} equal to $x$ if the latter is a scalar
(\typ{INT} or \kbd{ZV\_isscalar}$(x)$ is 1) and
\kbd{zk\_multable}$(\var{nf},x)$ otherwise. Shallow function.


The following routines implement multiplication in a commutative $R$-algebra,
generated by $(e_1 = 1,\dots, e_n)$, and given by a multiplication table $M$:
elements in the algebra are $n$-dimensional \typ{COL}s, and the matrix
$M$ is such that for all $1\leq i,j\leq n$, its column with index $(i-1)n +
j$, say $(c_k)$, gives $e_i\cdot e_j = \sum c_k e_k$. It is assumed that
$e_1$ is the neutral element for the multiplication (a convenient
optimization, true in practice for all multiplications we needed to implement).
If $x$ has any other type than \typ{COL} where an algebra element is
expected, it is understood as $x e_1$.

\fun{GEN}{multable}{GEN M, GEN x} given a column vector $x$, representing
the quantity $\sum_{i=1}^N x_i e_i$, returns the multiplication table by $x$.
Shallow function.

\fun{GEN}{ei_multable}{GEN M, long i} returns the multiplication table
by the $i$-th basis element $e_i$. Shallow function.

\fun{GEN}{tablemul}{GEN M, GEN x, GEN y} returns $x\cdot y$.

\fun{GEN}{tablesqr}{GEN M, GEN x} returns $x^2$.

\fun{GEN}{tablemul_ei}{GEN M, GEN x, long i} returns $x\cdot e_i$.

\fun{GEN}{tablemul_ei_ej}{GEN M, long i, long j} returns $e_i\cdot e_j$.

\fun{GEN}{tablemulvec}{GEN M, GEN x, GEN v} given a vector $v$ of elements
in the algebra, returns the $x\cdot v[i]$.

\subsec{Ideal arithmetic}

\misctitle{Conversion to HNF.}

\fun{GEN}{idealhnf}{GEN nf, GEN x} returns the HNF of the ideal defined by $x$:
$x$ may be an algebraic  number (defining a principal ideal),  a maximal ideal
(as given by \tet{idealprimedec} or  \tet{idealfactor}), or a matrix whose
columns give generators for the  ideal. This  last format is complicated,  but
useful to reduce general modules to the canonical form once in a while:

\item if strictly less than $N = [K:Q]$ generators are given,  $x$ is the
$\Z_K$-module they generate,

\item if $N$ or more are given,  it is assumed that they form a $\Z$-basis
(that the matrix has maximal rank $N$).  This acts as \tet{mathnf} since the
$\Z_K$-module structure is (taken for granted hence) not taken into account
in this case.

Extended ideals are also accepted, their principal part being discarded.

\fun{GEN}{idealhnf0}{GEN nf, GEN x, GEN y} returns the HNF of the ideal
generated by the two algebraic numbers $x$ and $y$.

The following low-level function underly the above two: they all assume
that \kbd{nf} is a true \var{nf} and perform no type checks:

\fun{GEN}{idealhnf_principal}{GEN nf, GEN x}
returns the ideal generated by the algebraic number $x$.

\fun{GEN}{idealhnf_shallow}{GEN nf, GEN x} is \tet{idealhnf} except that the
result may not be suitable for \kbd{gerepile}: if $x$ is already in HNF, we
return $x$, not a copy !

\fun{GEN}{idealhnf_two}{GEN nf, GEN v} assuming $a = v[1]$ is a non-zero
\typ{INT} and $b = v[2]$ is an algebraic integer, possibly given in regular
representation by a \typ{MAT} (the multiplication table by $b$, see
\tet{zk_multable}), returns the HNF of $a\Z_K+b\Z_K$.

\misctitle{Operations}

The basic ideal routines accept all \kbd{nf}s (\var{nf}, \var{bnf},
\var{bnr}) and ideals in any form, including extended ideals, and return
ideals in HNF, or an extended ideal when that makes sense:

\fun{GEN}{idealadd}{GEN nf, GEN x, GEN y} returns $x+y$.

\fun{GEN}{idealdiv}{GEN nf, GEN x, GEN y} returns $x/y$. Returns an extended
ideal if $x$ or $y$ is an extended ideal.

\fun{GEN}{idealmul}{GEN nf, GEN x, GEN y} returns $xy$.
Returns an extended ideal if $x$ or $y$ is an extended ideal.

\fun{GEN}{idealinv}{GEN nf, GEN x} returns $x^{-1}$.
Returns an extended ideal if $x$ is an extended ideal.

\fun{GEN}{idealpow}{GEN nf, GEN x, GEN n} returns $x^n$.
Returns an extended ideal if $x$ is an extended ideal.

\fun{GEN}{idealpows}{GEN nf, GEN ideal, long n} returns $x^n$.
Returns an extended ideal if $x$ is an extended ideal.

\fun{GEN}{idealmulred}{GEN nf, GEN x, GEN y} returns an extended ideal equal
to $xy$.

\fun{GEN}{idealpowred}{GEN nf, GEN x, GEN n} returns an extended ideal equal
to $x^n$.

More specialized routines suffer from various restrictions:

\fun{GEN}{idealdivexact}{GEN nf, GEN x, GEN y} returns $x/y$, assuming that
the quotient is an integral ideal. Much faster than \tet{idealdiv} when the
norm of the quotient is small compared to $Nx$. Strips the principal parts
if either $x$ or $y$ is an extended ideal.

\fun{GEN}{idealdivpowprime}{GEN nf, GEN x, GEN pr, GEN n} returns $x
\goth{p}^{-n}$, assuming $x$ is an ideal in HNF, and \kbd{pr}
a \var{prid} associated to $\goth{p}$. Not suitable for \tet{gerepileupto}
since it retunrs $x$ when $n = 0$.

\fun{GEN}{idealmulpowprime}{GEN nf, GEN x, GEN pr, GEN n} returns $x
\goth{p}^{n}$, assuming $x$ is an ideal in HNF, and \kbd{pr} a \var{prid}
associated to $\goth{p}$. Not suitable for \tet{gerepileupto} since it
retunrs $x$ when $n = 0$.

\fun{GEN}{idealprodprime}{GEN nf, GEN P} given a list $P$ of prime ideals
in \var{prid} form, return their product.

\fun{GEN}{idealmul_HNF}{GEN nf, GEN x, GEN y} returns $xy$, assuming
than \kbd{nf} is a true \var{nf}, $x$ is an integral ideal in HNF and $y$
is an integral ideal in HNF or precompiled form (see below).
For maximal speed, the ѕecond ideal $y$ may be given in precompiled form $y =
[a,b]$, where $a$ is a non-zero \typ{INT} and $b$ is an algebraic integer in
regular representation (a \typ{MAT} giving the multiplication table by the
fixed element): very useful when many ideals $x$ are going to be multiplied by
the same ideal $y$. This essentially reduces each ideal multiplication to
an $N\times N$ matrix multiplication followed by a $N\times 2N$ modular
HNF reduction (modulo $xy\cap \Z$).

\subsec{Reducing modulo maximal ideals}

\fun{GEN}{nfmodprinit}{GEN nf, GEN pr} returns an abstract \kbd{modpr}
structure, associated to reduction modulo the maximal ideal \kbd{pr}, in
\kbd{idealprimedec} format. From this data we can quickly project any
\kbd{pr}-integral number field element to the residue field. This function is
almost useless in library mode, we rather use:

\fun{GEN}{nf_to_Fq_init}{GEN nf, GEN *ppr, GEN *pT, GEN *pp} concrete
version of \kbd{nfmodprinit}: \kbd{nf} and \kbd{*ppr} are the inputs, the
return value is a \kbd{modpr} and \kbd{*ppr}, \kbd{*pT} and \kbd{*pp} are set
as side effects.

The input \kbd{*ppr} is either a maximal ideal or already a \kbd{modpr} (in
which case it is replaced by the underlying maximal ideal). The residue field
is realized as $\F_p[X]/(T)$ for some monic $T\in\F_p[X]$, and we set
\kbd{*pT} to $T$ and \kbd{*pp} to $p$. Set $T = \kbd{NULL}$ if the prime has
degree $1$ and the residue field is $\F_p$.

In short, this receives (or initializes) a \kbd{modpr} structure, and
extracts from it $T$, $p$ and $\goth{p}$.

\fun{GEN}{nf_to_Fq}{GEN nf, GEN x, GEN modpr} returns an \kbd{Fq} congruent
to $x$ modulo the maximal ideal associated to \kbd{modpr}. The output is
canonical: all elements in a given residue class are represented by the same
\kbd{Fq}.

\fun{GEN}{Fq_to_nf}{GEN x, GEN modpr} returns an \kbd{nf} element lifting
the residue field element $x$, either a \typ{INT} or an algebraic integer
in \kbd{algtobasis} format.

\fun{GEN}{zkmodprinit}{GEN nf, GEN pr} as \tet{nfmodprinit}, but we assume we
will only reduce algebraic integers, hence do not initialize data allowing to
remove denominators. More precisely, we can in fact still handle an $x$ whose
rational denominator is not $0$ in the residue field (i.e. if the valuation
of $x$ is non-negative at all primes dividing $p$).

\fun{GEN}{zk_to_Fq_init}{GEN nf, GEN *pr, GEN *T, GEN *p} as
\kbd{nf\_to\_ff\_init}, able to reduce only $p$-integral elements.

\fun{GEN}{zk_to_Fq}{GEN x, GEN modpr} as \kbd{nf\_to\_ff}, for
a $p$-integral $x$.

\fun{GEN}{nfM_to_FqM}{GEN M, GEN nf,GEN modpr} reduces a matrix
of \kbd{nf} elements to the residue field; returns an \kbd{FqM}.

\fun{GEN}{FqM_to_nfM}{GEN M, GEN modpr} lifts an \kbd{FqM} to a matrix of
\kbd{nf} elements.

\fun{GEN}{nfV_to_FqV}{GEN A, GEN nf,GEN modpr} reduces a vector
of \kbd{nf} elements to the residue field; returns an \kbd{FqV}
with the same type as \kbd{A} (\typ{VEC} or \typ{COL}).

\fun{GEN}{FqV_to_nfV}{GEN A, GEN modpr} lifts an \kbd{FqV} to a vector of
\kbd{nf} elements (same type as \kbd{A}).

\fun{GEN}{nfX_to_FqX}{GEN Q, GEN nf,GEN modpr} reduces a polynomial
with \kbd{nf} coefficients to the residue field; returns an \kbd{FqX}.

\fun{GEN}{FqX_to_nfX}{GEN Q, GEN modpr} lifts an \kbd{FqX} to a polynomial
with coefficients in \kbd{nf}.

\subsec{Signatures}

``Signs'' of the real embeddings of number field element are represented in
additive notation, using the standard identification $(\Z/2\Z, +) \to
(\{-1,1\},\times)$, $s\mapsto (-1)^s$.

With respect to a fixed \kbd{nf} structure, a selection of real places (a
divisor at infinity) is normally given as a \typ{VECSMALL} of indices of the
roots \kbd{nf.roots} of the defining polynomial for the number field. For
compatibility reasons, in particular under GP, the (obsolete) \kbd{vec01}
form is also accepted: a \typ{VEC} with \kbd{gen\_0} or \kbd{gen\_1} entries.

The following internal functions go back and forth between the two
representations for the archimedean part of divisors (GP: $0/1$ vectors,
library: list of indices):

\fun{GEN}{vec01_to_indices}{GEN v} given a \typ{VEC} $v$ with \typ{INT} entries
equal to $0$ or $1$, return as a \typ{VECSMALL} the list of indices $i$
such that $v[i] = 1$. If $v$ is already a \typ{VECSMALL}, return it
(not suitable for \kbd{gerepile} in this case).

\fun{GEN}{indices_to_vec01}{GEN p, long n} return the $0/1$ vector of length
$n$ with ones exactly at the positions $p[1], p[2], \ldots$


\fun{GEN}{nfsign}{GEN nf,GEN x} $x$ being a number field element and \kbd{nf}
any form of number field, return the $0-1$-vector giving the signs of the 
$r_1$ real embeddings of $x$, as a \typ{VECSMALL}. Linear algebra functions
like \tet{F2v_add_inplace} then allow keeping track of signs in series of
multiplications. 

If $x$ is a \typ{VEC} of number field elements, return the matrix whose
colums are the signs of the $x[i]$.

\fun{GEN}{nfsign_arch}{GEN nf,GEN x,GEN arch} \kbd{arch} being a list of
distinct real places, either in \kbd{vec01} (\typ{VEC} with \kbd{gen\_0} or
\kbd{gen\_1} entries) or \kbd{indices} (\typ{VECSMALL}) form (see
\tet{vec01_to_indices}), returns the signs of $x$ at the corresponding
places. This is the low-level function underlying \kbd{nfsign}.

\fun{GEN}{nfsign_units}{GEN bnf, GEN archp, int add_tu}
\kbd{archp} being a divisor at infinity in \kbd{indices} form
(or \kbd{NULL} for the divisor including all real places), return the signs
at \kbd{archp} of a system of fundamental units for the field, in the same
order as \kbd{bnf.tufu} if \kbd{add\_tu} is set; and in the same order as
\kbd{bnf.fu} otherwise.

\fun{GEN}{nfsign_from_logarch}{GEN L, GEN invpi, GEN archp} given $L$
the vector of the $\log \sigma(x)$, where $\sigma$ runs through the (real
or complex) embeddings of some number field, \kbd{invpi} being
a floating point approximation to $1/\pi$, and \kbd{archp} being a divisor
at infinity in \kbd{indices} form, return the signs of $x$
at the corresponding places. This is the low-level function underlying
\kbd{nfsign\_units}; the latter is actually a trivial wrapper
\kbd{bnf} structures include the $\log \sigma(x)$ for a system of fundamental
units of the field.

\fun{GEN}{set_sign_mod_divisor}{GEN nf, GEN x, GEN y, GEN module, GEN sarch}
let $f = f_0f_\infty$ be the divisor represented by \kbd{module}, $x$, $y$ two
number field elements. Returns $yt$ with $t = 1 \text{mod}^* f$ such that $x$
and $ty$ have the same signs at $f_\infty$; if $x =
\kbd{NULL}$, make $ty$ totally positive at $f_\infty$. \kbd{sarch} is the
output of \kbd{nfarchstar(nf, f0, finf)}.

\fun{GEN}{nfarchstar}{GEN nf, GEN f0, GEN finf} for a divisor $f =
f_0f_\infty$ represented by the integral ideal \kbd{f0} in HNF and
the \kbd{finf} in \kbd{indices} form, returns $(\Z_K/f_\infty)^*$ in a form
suitable for computations mod $f$. More precisely, returns
$[c, g, M]$, where $c = [2,\ldots, 2]$ gives the cyclic structure of that
group ($\#f_\infty$ copies of $\Z/2\Z$), $g$ a minimal system of independant
generators, which are furthermore congruent to $1$ mod $f_0$ (no condition if
$f_0 = \Z_K$), and $M$ is the matrix of signs of the $g[i]$ at $f_\infty$,
which is square and invertible over $\F_2$.

\subsec{Maximal order and discriminant}

A number field $K = \Q[X]/(T)$ is defined by a monic $T\in\Z[X]$. The
low-level function computing a maximal order is

\fun{void}{nfmaxord}{nfmaxord_t *S, GEN T, long flag, GEN fa}, where
the polynomial $T$ is as above.

The structure \tet{nfmaxord_t} is initialized by the call; it has the
following fields:
\bprog
  GEN dT, dK; /* discriminants of T and K */
  GEN index; /* index of power basis in maximal order */
  GEN dTP, dTE; /* factorization of |dT|, primes / exponents */
  GEN dKP, dKE; /* factorization of |dK|, primes / exponents */
  GEN basis; /* Z-basis for maximal order */
@eprog\noindent The exponent vectors are \typ{VECSMALL}. The primes
in \kbd{dTP} and \kbd{dKP} are pseudoprimes, not proven primes.

The \kbd{flag} is an or-ed combination of the binary flags:

\tet{nf_PARTIALFACT}: do not try to fully factor \kbd{dT} and only look for
primes less than \kbd{primelimit}. In that case, the elements in \kbd{dTP}
and \kbd{dKP} need not all be primes. But the resulting \kbd{dK},
\kbd{index} and \kbd{basis} are correct provided there exists no prime $p >
\kbd{primelimit}$ with $p^2$ divides the field discriminant \kbd{dK}.

\tet{nf_ROUND2}: use the ROUND2 algorithm instead of the default ROUND4
(do not use that, it is slower).

If \kbd{fa} is not \kbd{NULL}, it is assumed to be the factorisation of
the absolute value of the discriminant of $T$. It is not mandatory that all
entries in the first column be primes; this is useful if only a local  integral
basis  for  some small set of places is desired: only factors with exponents
greater or equal to $2$ will be considered.

\subsec{Obsolete routines}

Still provided for backward compatibility, but should not be used in new
programs. They will eventually disappear.

\fun{GEN}{zidealstar}{GEN nf, GEN x} short for \kbd{Idealstar(nf,x,nf\_GEN)}

\fun{GEN}{zidealstarinit}{GEN nf, GEN x}
short for \kbd{Idealstar(nf,x,nf\_INIT)}

\fun{GEN}{zidealstarinitgen}{GEN nf, GEN x}
short for \kbd{Idealstar(nf,x,nf\_GEN|nf\_INIT)}

\fun{GEN}{buchimag}{GEN D, GEN c1, GEN c2, GEN gCO} short for
\bprog
  Buchquad(D,gtodouble(c1),gtodouble(c2), /*ignored*/0)
@eprog

\fun{GEN}{buchreal}{GEN D, GEN gsens, GEN c1, GEN c2, GEN RELSUP, long prec}
short for
\bprog
Buchquad(D,gtodouble(c1),gtodouble(c2), prec)
@eprog

\section{Linear algebra over $\Z$}
\subsec{Hermite and Smith Normal Forms}

\fun{GEN}{ZM_hnf}{GEN x} returns the Hermite Normal Form of the \kbd{ZM} $x$
(removing $0$ columns), using the \tet{ZM_hnfall} algorithm. If you want the
true HNF, use \kbd{ZM\_hnfall(x, NULL, 0)}.

\fun{GEN}{ZM_hnfmod}{GEN x, GEN d} returns the HNF of the \kbd{ZM} $x$
(removing $0$ columns), assuming the \typ{INT} $d$ is a multiple of the
determinant of $x$. This is usually faster than \tet{ZM_hnf} (and uses less
memory) if the dimension is large, $> 50$ say.

\fun{GEN}{ZM_hnfmodid}{GEN x, GEN d} returns the HNF of the matrix $(x \mid d
\text{Id})$ (removing $0$ columns), for a \kbd{ZM} $x$ and a \typ{INT} $d$.

\fun{GEN}{ZM_hnfmodidpart}{GEN x, GEN d} as \tet{ZM_hnfmodid}, but return as
soon as the diagonal is known, saving time. Hence the entries to the right of
the pivots need not be reduced, i.e.~they may be large or negative.

\fun{GEN}{ZM_hnfall}{GEN x, GEN *U, long remove} returns the HNF $H$ of the
\kbd{ZM} $x$; if $U$ is not \kbd{NULL}, set if to the matrix $U$ such that
$x U = H$. If $\kbd{remove} = 0$, $H$ is the true HNF, including $0$
columns; if $\kbd{remove} = 1$, delete the $0$ columns from $H$ but do not
update $U$ accordingly (so that the integer kernel may still be recovered):
we no longer have $x U = H$;
if $\kbd{remove} = 2$, remove $0$ columns from $H$ and update $U$ so that
$x U = H$. The matrix $U$ is square and invertible unless $\kbd{remove} = 2$.

This routine uses a naive algorithm which is potentially exponential in the
dimension but is fast in practice, although it may require lots of memory;
the base change matrix $U$ may be very large (when the kernel is large).

\fun{GEN}{ZM_hnfperm}{GEN A, GEN *ptU, GEN *ptperm} returns the hnf
$H = P A U$ of the matrix $P A$, where $P$ is a suitable permutation matrix,
and $U\in \text{Gl}_n(\Z)$. $P$ is chosen so as to (heuristically) minimize the
size of $U$; in this respect it is less efficient than \kbd{ZM\_hnflll}
but usually faster. Set \kbd{*ptU} to $U$ and \kbd{*pterm} to a \typ{VECSMALL}
representing the row permutation associated to $P = (\delta_{i,\kbd{perm}[i]}$.
If \kbd{ptU} is set to \kbd{NULL}, $U$ is not computed, saving some time;
although useless, setting \kbd{ptperm} to \kbd{NULL} is also allowed.

\fun{GEN}{ZM_hnflll}{GEN x, GEN *U, int remove} returns the HNF $H$ of the
\kbd{ZM} $x$; if $U$ is not \kbd{NULL}, set if to the matrix $U$ such that $x
U = H$. The meaning of \kbd{remove} is the same as in \tet{ZM_hnfall}.

This routine uses the \idx{LLL} variant of Havas, Majewski and Mathews, which is
polynomial time, but rather slow in practice because it uses an exact LLL
over the integers instead of a floating point variant; it uses polynomial
space but lots of memory is needed for large dimensions, say larger than 300.
On the other hand, the base change matrix $U$ is essentially optimally small
with respect to the $L_2$ norm.

\fun{GEN}{ZM_hnfcenter}{GEN M}. Given a \kbd{ZM} in HNF $M$, update it in
place so that non-diagonal entries belong to a system of \emph{centered}
residues. Not suitable for gerepile.

\fun{GEN}{ZM_snf}{GEN x} returns the Smith Normal Form (vector of
elementary divisors) of the \kbd{ZM} $x$.

\fun{GEN}{ZM_snfall}{GEN x, GEN *U, GEN *V} returns
\kbd{ZM\_smith(x)} and sets $U$ and $V$ to unimodular matrices such that $U\,
x\, V = D$ (diagonal matrix of elementary divisors). Either (or both) $U$ or
$V$ may be \kbd{NULL} in which case the corresponding matrix is not computed.

\fun{GEN}{ZM_snfall_i}{GEN x, GEN *U, GEN *V, int returnvec} same as
\kbd{ZM\_snfall}, except that, depending on the value of \kbd{returnvec}, we
either return a diagonal matrix (as in \kbd{ZM\_snfall}, \kbd{returnvec} is 0)
or a vector of elementary divisors (as in \kbd{ZM\_snf}, \kbd{returnvec} is 1) .

\fun{void}{ZM_snfclean}{GEN d, GEN U, GEN V} assuming $d$, $U$, $V$ come
from \kbd{d = ZM\_snfall(x, \&U, \&V)}, where $U$ or $V$ may be \kbd{NULL},
cleans up the output in place. This means that elementary divisors equal to 1
are deleted and $U$, $V$ are updated. The output is not suitable for
\kbd{gerepileupto}.

The following 3 routines underly the various \tet{matrixqz} variants.
In all case the $m\times n$ \typ{MAT} $x$ is assumed to have rational
(\typ{INT} and \typ{FRAC}) coefficients

\fun{GEN}{QM_ImQ_hnf}{GEN x} returns an HNF basis for
$\text{Im}_\Q x \cap \Z^n$.

\fun{GEN}{QM_ImZ_hnf}{GEN x} returns an HNF basis for
$\text{Im}_\Z x \cap \Z^n$.

\fun{GEN}{QM_minors_coprime}{GEN x, GEN D}, assumes $m\geq n$, and returns
a matrix in $M_{m,n}(\Z)$ with the same $\Q$-image as $x$, such that
the GCD of all $n\times n$ minors is coprime to $D$; if $D$ is \kbd{NULL},
we want the GCD to be $1$.
\smallskip

The following routines are simple wrappers around the above ones and are
normally useless in library mode:

\fun{GEN}{hnf}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls \tet{ZM_hnf}.
Normally useless in library mode.

\fun{GEN}{hnfmod}{GEN x, GEN d} checks whether $x$ is a \kbd{ZM}, then calls
\tet{ZM_hnfmod}. Normally useless in library mode.

\fun{GEN}{hnfmodid}{GEN x,GEN d} checks whether $x$ is a \kbd{ZM}, then calls
\tet{ZM_hnfmodid}. Normally useless in library mode.

\fun{GEN}{hnfall}{GEN x} calls
\kbd{ZM\_hnfall(x, \&U, 1)} and returns $[H, U]$. Normally useless in library
mode.

\fun{GEN}{hnflll}{GEN x} calls \kbd{ZM\_hnflll(x, \&U, 1)} and returns $[H,
U]$. Normally useless in library mode.

\fun{GEN}{hnfperm}{GEN x} calls \kbd{ZM\_perm(x, \&U, \&P)} and returns $[H, U,
P]$. Normally useless in library mode.

\fun{GEN}{smith}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls
\kbd{ZM\_smith}. Normally useless in library mode.

\fun{GEN}{smithall}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls
\kbd{ZM\_smithall(x, \&U, \&V)} and returns $[U,V,D]$. Normally useless in
library mode.

\subsec{The LLL algorithm}\sidx{LLL}

The basic GP functions and their immediate variants are normally not very
useful in library mode. We briefly list them here for completeness, see the
documentation of \kbd{qflll} and \kbd{qflllgram} for details:

\item \fun{GEN}{qflll0}{GEN x, long flag}

\fun{GEN}{lll}{GEN x} \fl = 0

\fun{GEN}{lllint}{GEN x} \fl = 1

\fun{GEN}{lllkerim}{GEN x} \fl = 4

\fun{GEN}{lllkerimgen}{GEN x} \fl = 5

\fun{GEN}{lllgen}{GEN x} \fl = 8

\item \fun{GEN}{qflllgram0}{GEN x, long flag}

\fun{GEN}{lllgram}{GEN x} \fl = 0

\fun{GEN}{lllgramint}{GEN x} \fl = 1

\fun{GEN}{lllgramkerim}{GEN x} \fl = 4

\fun{GEN}{lllgramkerimgen}{GEN x} \fl = 5

\fun{GEN}{lllgramgen}{GEN x} \fl = 8

\smallskip

The basic workhorse underlying all integral and floating point LLLs is

\fun{GEN}{ZM_lll}{GEN x, double D, long flag}, where $x$ is a \kbd{ZM};
$D \in ]1/4,1[$ is the Lov\'{a}sz constant determining the frequency of
swaps during the algorithm: a larger values means better guarantees for the
basis (in principle smaller basis vectors) but slower runtimes (suggested
value: $D = 0.99$).

\misctitle{Important:} This function does not collect garbage and its output
is not suitable for either \kbd{gerepile} or \kbd{gerepileupto}. We expect
the caller to do something simple with the output (e.g. matrix
multiplication), then collect garbage immediately.

\noindent\kbd{flag} is an or-ed combination of the following flags:

\item  \tet{LLL_GRAM}. If set, the input matrix $x$ is the Gram matrix ${}^t
v v$ of some lattice vectors $v$.

\item  \tet{LLL_INPLACE}. If unset, we return the base change matrix $U$,
otherwise the transformed matrix $x U$ or ${}^t U x U$ (\kbd{LLL\_GRAM}).
Implies \tet{LLL_IM} (see below).

\item  \tet{LLL_KEEP_FIRST}. The first vector in the output basis is the same
one as was originally input. Provided this is a shortest non-zero vector of
the lattice, the output basis is still LLL-reduced. This is used to reduce
maximal orders of number fields with respect to the $T_2$ quadratic form, to
ensure that the first vector in the output basis corresponds to $1$ (which is
a shortest vector).

The last three flags are mutually exclusive, either 0 or a single one must be
set:

\item  \tet{LLL_KER} If set, only return a kernel basis $K$ (not LLL-reduced).

\item  \tet{LLL_IM} If set, only return an LLL-reduced lattice basis $T$.
(This is implied by \tet{LLL_INPLACE}).

\item  \tet{LLL_ALL} If set, returns a 2-component vector $[K, T]$
corresponding to both kernel and image.


\fun{GEN}{lllfp}{GEN x, double D, long flag} is a variant for matrices
with inexact entries: $x$ is a matrix with real coefficients (types
\typ{INT}, \typ{FRAC} and \typ{REAL}), $D$ and $\fl$ are as in \tet{ZM_lll}.
The matrix is rescaled, rounded to nearest integers, then fed to
\kbd{ZM\_lll}. The flag \kbd{LLL\_INPLACE} is still accepted but less useful
(it returns an LLL-reduced basis associated to rounded input, instead of an
exact base change matrix).

\fun{GEN}{ZM_lll_norms}{GEN x, double D, long flag, GEN *ptB} slightly more
general version of \kbd{ZM\_lll}, setting \kbd{*ptB} to a vector containing
the squared norms of the Gram-Schmidt vectors $(b_i^*)$ associated to the
output basis $(b_i)$, $b_i^* = b_i + \sum_{j < i} \mu_{i,j} b_j^*$.


\fun{GEN}{lllintpartial_inplace}{GEN x} given a \kbd{ZM} $x$ of maximal rank,
returns a partially reduced basis $(b_i)$ for the space spanned by the
columns of $x$: $|b_i \pm b_j| \geq |b_i|$ for any two distinct basis vectors
$b_i$, $b_j$. This is faster than the LLL algorithm, but produces much larger
bases.

\fun{GEN}{lllintpartial}{GEN x} as \kbd{lllintpartial\_inplace}, but returns
the base change matrix $U$ from the canonical basis to the $b_i$, i.e. $x U$
is the output of \kbd{lllintpartial\_inplace}.

\subsec{Reduction modulo matrices}

\fun{GEN}{ZC_hnfremdiv}{GEN x, GEN y, GEN *Q} assuming $y$ is an
invertible \kbd{ZM} in HNF and $x$ is a \kbd{ZC}, returns the \kbd{ZC} $R$
equal to $x$ mod $y$ (whose $i$-th entry belongs to $[-y_{i,i}/2, y_{i,i}/2[$).
Stack clean \emph{unless} $x$ is already reduced (in which case, returns $x$
itself, not a copy). If $Q$ is not \kbd{NULL}, set it to the \kbd{ZC} such that
$x = yQ + R$.

\fun{GEN}{ZM_hnfremdiv}{GEN x, GEN y, GEN *Q} reduce
each column of the \kbd{ZM} $x$ using \kbd{ZC\_hnfremdiv}. If $Q$ is not
\kbd{NULL}, set it to the \kbd{ZM} such that $x = yQ + R$.

\fun{GEN}{ZC_hnfrem}{GEN x, GEN y} alias for \kbd{ZC\_hnfremdiv(x,y,NULL)}.

\fun{GEN}{ZM_hnfrem}{GEN x, GEN y} alias for \kbd{ZM\_hnfremdiv(x,y,NULL)}.

Besises the \emph{hnfrem} functions, which were specific to integral input,
we also have:

\fun{GEN}{reducemodinvertible}{GEN x, GEN y} $y$ is an invertible matrix
and $x$ a \typ{COL} or \typ{MAT} of compatible dimension.
Returns $x - y\lfloor y^{-1}x \rceil$, which has small entries and differs
from $x$ by an integral linear combination of the columns of $y$. Suitable
for \kbd{gerepileupto}, but does not collect garbage.

\fun{GEN}{closemodinvertible}{GEN x, GEN y} returns $x -
\kbd{reducemodinvertible}(x,y)$, i.e. an integral linear comination of
the columns of $y$, which is close to $x$.

\fun{GEN}{reducemodlll}{GEN x,GEN y} LLL-reduce the \kbd{ZM} $y$ and call
\kbd{reducemodinvertible} to find a small representative of $x$ mod $y \Z^n$.
Suitable for \kbd{gerepileupto}, but does not collect garbage.

