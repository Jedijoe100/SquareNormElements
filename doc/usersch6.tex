% $Id: usersch6.tex 10212 2008-05-30 23:21:35Z kb $
% Copyright (c) 2000  The PARI Group
%
% This file is part of the PARI/GP documentation
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU General Public License
\chapter{Technical Reference Guide for Algebraic Number Theory}

\section{General Number Fields}

\subsec{Number field types}

None of the following routines thoroughly check their intput: they
distinguish between \emph{bona fide} structures as output by PARI routines,
but designing perverse data will easily fool them. To give an example, a
square matrix will be interpreted as an ideal even though the $\Z$-module
generated by its columns may not be an $O_K$-module (i.e. the expensive
\kbd{nfisideal} routine will \emph{not} be called).

\fun{long}{nftyp}{GEN x}. Returns the type of number field structure stored in
\kbd{x}, \tet{typ_NF}, \tet{typ_BNF}, or \tet{typ_BNR}. Other answers
are possible, meaning \kbd{x} is not a number field structure.

\fun{GEN}{get_nf}{GEN x, long *t}. Extract an \var{nf} structure from
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{get_bnf}{GEN x, long *t}. Extract a \kbd{bnf} structure from
\kbd{x} if possible and return it, otherwise return \kbd{NULL}. Sets
\kbd{t} to the \kbd{nftyp} of \kbd{x} in any case.

\fun{GEN}{get_nfpol}{GEN x, GEN *nf} try to extract and \var{nf} structure
from \kbd{x}, and sets \kbd{*nf} to \kbd{NULL} (failure) or to the \var{nf}.
Returns the (monic, integral) polynomial defining the field.

\fun{GEN}{get_bnfpol}{GEN x, GEN *bnf, GEN *nf} try to extract a \var{bnf}
and an \var{nf} structure from \kbd{x}, and sets \kbd{*bnf}
and \kbd{*nf} to \kbd{NULL} (failure) or to the corresponding structure.
Returns the (monic, integral) polynomial defining the field.

\fun{GEN}{checknf}{GEN x} if an \var{nf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_nf} is often more flexible.

\fun{GEN}{checkbnf}{GEN x} if an \var{bnf} structure can be extracted from
\kbd{x}, return it; otherwise raise an exception. The more general
\kbd{get\_bnf} is often more flexible.

\fun{void}{checkbnr}{GEN bnr} Raise an exception if the argument
is not a \var{bnr} structure.

\fun{void}{checkbnrgen}{GEN bnr} Raise an exception if the argument is not a
\var{bnr} structure, complete with explicit generators for the ray class group.

\fun{void}{checkrnf}{GEN rnf} Raise an exception if the argument is not an
\var{rnf} structure.

\fun{void}{checkbid}{GEN bid} Raise an exception if the argument is not a
\var{bid} structure.

\fun{GEN}{checkgal}{GEN x} if a \var{galoisinit} structure can be extracted
from \kbd{x}, return it; otherwise raise an exception.

\fun{void}{checksqmat}{GEN x, long N} check whether \kbd{x} is a square matrix
of dimension \kbd{N}. May be used to check for ideals if \kbd{N} is the field
degree.

\fun{void}{checkprimeid}{GEN bid} Raise an exception if the argument is not a
prime ideal structure.

\fun{void}{checkmodpr}{GEN modpr} Raise an exception if the argument is not a
 prime ideal structure.

\fun{GEN}{checknfelt_mod}{GEN nf, GEN x, char *s} Given an \var{nf} structure
\kbd{nf} and a \typ{POLMOD} \kbd{x}, return the associated polynomial
representative (shallow) if \kbd{x} and \kbd{nf} are compatible. Raise an
eception otherwise.

\fun{long}{idealtyp}{GEN *ideal, GEN *arch} The input is \kbd{ideal}, a pointer
to an ideal or idele, which is usually modified, \kbd{arch} being set as a
side-effect. Returns the type of the underlying ideal among
\tet{id_PRINCIPAL} (a number field element), \tet{id_PRIME} (a prime ideal)
\tet{id_MAT} (an ideal in matrix form).

If \kbd{ideal} pointed to an ideal, set \kbd{arch} to \kbd{NULL}, and
possibly simplify \kbd{ideal} (for instance an $N\times 1$ matrix is replaced
by an elment in \typ{COL} form). If it pointed to an idele, replace
\kbd{ideal} by the underlying ideal and set \kbd{arch} to the archimedean
component.

\subsec{Extracting info from a \kbd{nf} structure}

These function expect a true \var{nf} argument, e.g.~a \var{bnf} will not
work.

\fun{long}{nf_get_r1}{GEN nf} returns the number of real places $r_1$.

\fun{long}{nf_get_r2}{GEN nf} returns the number of complex places $r_2$.

\fun{void}{nf_get_sign}{GEN nf, long *r1, long *r2} sets $r_1$ and $r_2$
to the number of real and complex places respectively. Note that
$r_1+2r_2$ is the field degree.

\fun{GEN}{nf_get_roots}{GEN nf} returns the complex roots of the polynomial
defining the number fields: first the $r_1$ real roots (as \typ{REAL}s),
then the $r_2$ pairs of complex conjugates.

\fun{long}{nf_get_prec}{GEN nf} returns the precision (in words) to which the
\var{nf} was computed.

\fun{GEN}{nf_to_scalar_or_basis}{GEN nf, GEN x} let $x$ be a number field
element. If it is a rational scalar, i.e.~can be represented by a \typ{INT}
or \typ{FRAC}, return the latter. Otherwise returns its basis representation
(\tet{nfalgtobasis}). Shallow function.

\fun{GEN}{nf_to_scalar_or_alg}{GEN nf, GEN x} let $x$ be a number field
element. If it is a rational scalar, i.e.~can be represented by a \typ{INT}
or \typ{FRAC}, return the latter. Otherwise returns its lifted \typ{POLMOD}
representation (lifted \tet{nfbasistoalg}). Shallow function.

\fun{GEN}{RgX_to_nfX}{GEN nf, GEN x} let $x$ be a polynomial whose coefficients
are number field elements; apply \kbd{nf\_to\_scalar\_or\_basis} to each
coefficient and return the resulting new polynomial. Shallow function.

\subsec{Increasing accuracy}

\fun{GEN}{nfnewprec}{GEN x, long prec}. Raise an exception if \kbd{x}
is not a number field structure (\var{nf}, \var{bnf} or \var{bnr}).
Otherwise, sets its accuracy to \kbd{prec} and return the new structure.
This is mostly useful with \kbd{prec} larger than the accuracy to
which \kbd{x} was computed, but it is also possible to decrease the accuracy
of \kbd{x} (truncating relevant components, which may speed up later
computations). This routine may modify the original \kbd{x} (see below).

This routine is straighforward for \var{nf} structures, but for the
other ones, it requires all principal ideals corresponding to the \var{bnf}
relations in algebraic form (they are originally only available via floating
point approximations). This in turn requires many calls to
\kbd{bnfisprincipal}, which is often slow, and may fail if the initial
accuracy was too low. In this case, the routine will not actually fail but
recomputes a \var{bnf} from scratch!

Since this process may be very expensive, the corresponding data is cached
(as a \emph{clone}) in the \emph{original} \kbd{x} so that later precision
increases become very fast. In particular, the copy returned by
\kbd{nfnewprec} also contains this additional data.

\fun{GEN}{bnfnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts
a \var{bnf} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{bnrnewprec}{GEN x, long prec}. As \kbd{nfnewprec}, but extracts a
\var{bnr} structure form \kbd{x} before increasing its accuracy, and
returns only the latter.

\fun{GEN}{nfnewprec_shallow}{GEN nf, long prec}

\fun{GEN}{bnfnewprec_shallow}{GEN bnf, long prec}

\fun{GEN}{bnrnewprec_shallow}{GEN bnr, long prec} Shallow functions
underlying the above, except that the first argument must now have the
corresponding number field type. I.e. one cannot call
\kbd{nfnewprec\_shallow(nf, prec)} if \kbd{nf} is actually a \var{bnf}.

\subsec{Reducing modulo maximal ideals}

\fun{GEN}{nfmodprinit}{GEN nf, GEN pr} returns an abstract \kbd{modpr}
structure, associated to reduction modulo the maximal ideal \kbd{pr}, in
\kbd{idealprimedec} format. From this data we can quickly project any
\kbd{pr}-integral $x$ to the residue field. This function is almost useless
in library mode, we rather use:

\fun{GEN}{nf_to_Fq_init}{GEN nf, GEN *ppr, GEN *pT, GEN *pp} a concrete
version of \kbd{nfmodprinit}: \kbd{nf} and \kbd{*ppr} are the inputs, the
return value is a \kbd{modpr} and \kbd{*ppr}, \kbd{*pT} and \kbd{*pp} are set
as side effects.

The input \kbd{*ppr} is either a maximal ideal or already a \kbd{modpr} (in
which case it is replaced by the underlying maximal ideal). The residue field
is realized as $\F_p[X]/(T)$ for some monic $T\in\F_p[X]$, and we set
\kbd{*pT} to $T$ and \kbd{*pp} to $p$. Set $T = \kbd{NULL}$ if the prime has
degree $1$ and the residue field is $\F_p$.

In short, this receives (or initializes) a \kbd{modpr} structure, and
extracts from it $T$, $p$ and $\goth{p}$.

\fun{GEN}{nf_to_Fq}{GEN nf, GEN x, GEN modpr} returns an \kbd{Fq} congruent
to $x$ modulo the maximal ideal associated to \kbd{modpr}. The output is
canonical: all elements in a given residue class are represented by the same
\kbd{Fq}.

\fun{GEN}{Fq_to_nf}{GEN x, GEN modpr} returns an \kbd{nf} element lifting
the residue field element $x$, either a \typ{INT} or an algebraic integer
in \kbd{algtobasis} format.

\fun{GEN}{zkmodprinit}{GEN nf, GEN pr} as \tet{nfmodprinit}, but we assume we
will only reduce algebraic integers, hence do not initialize data allowing to
remove denominators. More precisely, we can in fact still handle an $x$ whose
denominator is not $0$ in the residue field (i.e. if the valuation
of $x$ is non-negative at all primes dividing $p$).

\fun{GEN}{zk_to_Fq_init}{GEN nf, GEN *pr, GEN *T, GEN *p} as
\kbd{nf\_to\_ff\_init}, able to reduce only $p$-integral elements.

\fun{GEN}{zk_to_Fq}{GEN x, GEN modpr} as \kbd{nf\_to\_ff}, for
a $p$-integral $x$.

\fun{GEN}{nfM_to_FqM}{GEN M, GEN nf,GEN modpr} reduces a matrix
of \kbd{nf} elements to the residue field; returns an \kbd{FqM}.

\fun{GEN}{FqM_to_nfM}{GEN M, GEN modpr} lifts an \kbd{FqM} to a matrix of
\kbd{nf} elements.

\fun{GEN}{nfV_to_FqV}{GEN A, GEN nf,GEN modpr} reduces a vector
of \kbd{nf} elements to the residue field; returns an \kbd{FqV}
with the same type as \kbd{A} (\typ{VEC} or \typ{COL}).

\fun{GEN}{FqV_to_nfV}{GEN A, GEN modpr} lifts an \kbd{FqV} to a vector of
\kbd{nf} elements (same type as \kbd{A}).

\fun{GEN}{nfX_to_FqX}{GEN Q, GEN nf,GEN modpr} reduces a polynomial
with \kbd{nf} coefficients to the residue field; returns an \kbd{FqX}.

\fun{GEN}{FqX_to_nfX}{GEN Q, GEN modpr} lifts an \kbd{FqX} to a polynomial
with coefficients in \kbd{nf}.

\subsec{Signatures}

``Signs'' of the real embeddings of number field element are represented in
additive notation, using the standard identification $(\Z/2\Z, +) \to
(\{-1,1\},\times)$, $s\mapsto (-1)^s$.

With respect to a fixed \kbd{nf} structure, a selection of real places (a
divisor at infinity, the archimedean part of PARI ideles) is normally given as
a \typ{VECSMALL} of indices of the roots \kbd{nf.roots} of the defining
polynomial for the number field. For compatibility reasons, in particular under
GP, the (obsolete) \kbd{vec01} form is also accepted: a \typ{VEC} with
\kbd{gen\_0} or \kbd{gen\_1} entries.

The following internal functions go back and forth between the two
representations for the archimedean part of ideles (GP: $0/1$ vectors, library:
list of indices):

\fun{GEN}{vec01_to_indices}{GEN v} given a \typ{VEC} $v$ with \typ{INT} entries
equal to $0$ or $1$, return as a \typ{VECSMALL} the list of indices $i$
such that $v[i] = 1$. If $v$ is already a \typ{VECSMALL}, return it
(not suitable for \kbd{gerepile} in this case).

\fun{GEN}{indices_to_vec01}{GEN p, long n} return the $0/1$ vector of length
$n$ with ones exactly at the positions $p[1], p[2], \ldots$


\fun{GEN}{nfsign}{GEN nf,GEN x} $x$ being a number field element and \kbd{nf}
any form of number field, return the $0-1$-vector giving the signs of the 
$r_1$ real embeddings of $x$, as a \typ{VECSMALL}. Linear algebra functions
like \tet{F2v_add_inplace} then allow keeping track of signs in series of
multiplications. 

If $x$ is a \typ{VEC} of number field elements, return the matrix whose
colums are the signs of the $x[i]$.

\fun{GEN}{nfsign_arch}{GEN nf,GEN x,GEN arch} \kbd{arch} being a list of
distinct real places, either in \kbd{vec01} (\typ{VEC} with \kbd{gen\_0} or
\kbd{gen\_1} entries) or \kbd{indices} (\typ{VECSMALL}) form (see
\tet{vec01_to_indices}), returns the signs of $x$ at the corresponding
places. This is the low-level function underlying \kbd{nfsign}.

\fun{GEN}{nfsign_units}{GEN bnf, GEN archp, int add_tu}
\kbd{archp} being a divisor at infinity in \kbd{indices} form
(or \kbd{NULL} for the divisor including all real places), return the signs
at \kbd{archp} of a system of fundamental units for the field, in the same
order as \kbd{bnf.tufu} if \kbd{add\_tu} is set; and in the same order as
\kbd{bnf.fu} otherwise.

\fun{GEN}{nfsign_from_logarch}{GEN L, GEN invpi, GEN archp} given $L$
the vector of $\log \sigma(x)$, where $\sigma$ runs through the (real
or complex) embeddings of some number field, \kbd{invpi} being
a floating point approximation to $1/\pi$, and \kbd{archp} being a divisor
at infinity in \kbd{indices} form, return the signs of $x$
at the corresponding places. This is the low-level function underlying
\kbd{nfsign\_units}; the latter is actually a trivial wrapper
\kbd{bnf} structures include the $\log \sigma(x)$ for a system of fundamental
units of the field.

\fun{GEN}{set_sign_mod_idele}{GEN nf, GEN x, GEN y, GEN idele, GEN sarch}
let $f = f_0f_\infty$ be the divisor represented by \kbd{idele}, $x$, $y$ two
number field elements. Returns $yt$ with $t = 1 \text{mod}^* f$ such that $x$
and $ty$ have the same signs at $f_\infty$; if $x =
\kbd{NULL}$, make $ty$ totally positive at $f_\infty$. \kbd{sarch} is the
output of \kbd{nfarchstar(nf, f0, finf)}.

\fun{GEN}{nfarchstar}{GEN nf, GEN f0, GEN finf} for a divisor $f =
f_0f_\infty$ represented by the integral ideal \kbd{f0} in HNF and
the \kbd{finf} in \kbd{indices} form, returns $(\Z_K/f_\infty)^*$ in a form
suitable for computations mod $f$. More precisely, returns
$[c, g, M]$, where $c = [2,\ldots, 2]$ gives the cyclic structure of that
group ($\#f_\infty$ copies of $\Z/2\Z$), $g$ a minimal system of independant
generators, which are furthermore congruent to $1$ mod $f_0$ (no condition if
$f_0 = \Z_K$), and $M$ is the matrix of signs of the $g[i]$ at $f_\infty$,
which is square and invertible over $\F_2$.

\subsec{Maximal order and discriminant}

A number field $K = \Q[X]/(T)$ is defined by a monic $T\in\Z[X]$. The
low-level function computing a maximal order is

\fun{void}{nfmaxord}{nfmaxord_t *S, GEN T, long flag, GEN fa}, where
the polynomial $T$ is as above.

The structure \tet{nfmaxord_t} is initialized by the call; it has the
following fields:
\bprog
  GEN dT, dK; /* discriminants of T and K */
  GEN index; /* index of power basis in maximal order */
  GEN dTP, dTE; /* factorization of |dT|, primes / exponents */
  GEN dKP, dKE; /* factorization of |dK|, primes / exponents */
  GEN basis; /* Z-basis for maximal order */
@eprog\noindent The exponent vectors are \typ{VECSMALL}. The primes
in \kbd{dTP} and \kbd{dKP} are pseudoprimes, not proven primes.

The \kbd{flag} is an or-ed combination of the binary flags:

\tet{nf_PARTIALFACT}: do not try to fully factor \kbd{dT} and only look for
primes less than \kbd{primelimit}. In that case, the elements in \kbd{dTP}
and \kbd{dKP} need not all be primes. But the resulting \kbd{dK},
\kbd{index} and \kbd{basis} are correct provided there exists no prime $p >
\kbd{primelimit}$ with $p^2$ divides the field discriminant \kbd{dK}.

\tet{nf_ROUND2}: use the ROUND2 algorithm instead of the default ROUND4
(do not use that, it is slower).

If \kbd{fa} is not \kbd{NULL}, it is assumed to be the factorisation of
the absolute value of the discriminant of $T$. It is not mandatory that all
entries in the first column be primes; this is useful if only a local  integral
basis  for  some small set of places is desired: only factors with exponents
greater or equal to $2$ will be considered.

\subsec{Obsolete routines}

Still provided for backward compatibility, but should not be used in new
programs.

\fun{GEN}{zidealstar}{GEN nf, GEN x} short for \kbd{Idealstar(nf,x,nf\_GEN)}

\fun{GEN}{zidealstarinit}{GEN nf, GEN x}
short for \kbd{Idealstar(nf,x,nf\_INIT)}

\fun{GEN}{zidealstarinitgen}{GEN nf, GEN x}
short for \kbd{Idealstar(nf,x,nf\_GEN|nf\_INIT)}

\section{Linear algebra over $\Z$}
\subsec{Hermite and Smith Normal Forms}

\fun{GEN}{ZM_hnf}{GEN x} returns the Hermite Normal Form of the \kbd{ZM} $x$
(removing $0$ columns), using the \tet{ZM_hnfall} algorithm. If you want the
true HNF, use \kbd{ZM\_hnfall(x, NULL, 0)}.

\fun{GEN}{ZM_hnfmod}{GEN x, GEN d} returns the HNF of the \kbd{ZM} $x$
(removing $0$ columns), assuming the \typ{INT} $d$ is a multiple of the
determinant of $x$. This is usually faster than \tet{ZM_hnf} (and uses less
memory) if the dimension is large, $> 50$ say.

\fun{GEN}{ZM_hnfmodid}{GEN x, GEN d} returns the HNF of the matrix $(x \mid d
\text{Id})$ (removing $0$ columns), for a \kbd{ZM} $x$ and a \typ{INT} $d$.

\fun{GEN}{ZM_hnfmodidpart}{GEN x, GEN d} as \tet{ZM_hnfmodid}, but return as
soon as the diagonal is known, saving time. Hence the entries to the right of
the pivots need not be reduced, i.e.~they may be large or negative.

\fun{GEN}{ZM_hnfall}{GEN x, GEN *U, long remove} returns the HNF $H$ of the
\kbd{ZM} $x$; if $U$ is not \kbd{NULL}, set if to the matrix $U$ such that
$x U = H$. If $\kbd{remove} = 0$, $H$ is the true HNF, including $0$
columns; if $\kbd{remove} = 1$, delete the $0$ columns from $H$ but do not
update $U$ accordingly (so that the integer kernel may still be recovered):
we no longer have $x U = H$;
if $\kbd{remove} = 2$, remove $0$ columns from $H$ and update $U$ so that
$x U = H$. The matrix $U$ is square and invertible unless $\kbd{remove} = 2$.

This routine uses a naive algorithm which is potentially exponential in the
dimension but is fast in practice, although it may require lots of memory;
the base change matrix $U$ may be very large (when the kernel is large).

\fun{GEN}{ZM_hnfperm}{GEN A, GEN *ptU, GEN *ptperm} returns the hnf
$H = P A U$ of the matrix $P A$, where $P$ is a suitable permutation matrix,
and $U\in \text{Gl}_n(\Z)$. $P$ is chosen so as to (heuristically) minimize the
size of $U$; in this respect it is less efficient than \kbd{ZM\_hnflll}
but usually faster. Set \kbd{*ptU} to $U$ and \kbd{*pterm} to a \typ{VECSMALL}
representing the row permutation associated to $P = (\delta_{i,\kbd{perm}[i]}$.
If \kbd{ptU} is set to \kbd{NULL}, $U$ is not computed, saving some time;
although useless, setting \kbd{ptperm} to \kbd{NULL} is also allowed.

\fun{GEN}{ZM_hnflll}{GEN x, GEN *U, int remove} returns the HNF $H$ of the
\kbd{ZM} $x$; if $U$ is not \kbd{NULL}, set if to the matrix $U$ such that $x
U = H$. The meaning of \kbd{remove} is the same as in \tet{ZM_hnfall}.

This routine uses the \idx{LLL} variant of Havas, Majewski and Mathews, which is
polynomial time, but rather slow in practice because it uses an exact LLL
over the integers instead of a floating point variant; it uses polynomial
space but lots of memory is needed for large dimensions, say larger than 300.
On the other hand, the base change matrix $U$ is essentially optimally small
with respect to the $L_2$ norm.

\fun{GEN}{ZM_hnfcenter}{GEN M}. Given a \kbd{ZM} in HNF $M$, update it in
place so that non-diagonal entries belong to a system of \emph{centered}
residues. Not suitable for gerepile.

\fun{GEN}{ZM_snf}{GEN x} returns the Smith Normal Form (vector of
elementary divisors) of the \kbd{ZM} $x$.

\fun{GEN}{ZM_snfall}{GEN x, GEN *U, GEN *V} returns
\kbd{ZM\_smith(x)} and sets $U$ and $V$ to unimodular matrices such that $U\,
x\, V = D$ (diagonal matrix of elementary divisors). Either (or both) $U$ or
$V$ may be \kbd{NULL} in which case the corresponding matrix is not computed.

\fun{GEN}{ZM_snfall_i}{GEN x, GEN *U, GEN *V, int returnvec} same as
\kbd{ZM\_snfall}, except that, depending on the value of \kbd{returnvec}, we
either return a diagonal matrix (as in \kbd{ZM\_snfall}, \kbd{returnvec} is 0)
or a vector of elementary divisors (as in \kbd{ZM\_snf}, \kbd{returnvec} is 1) .

\fun{void}{ZM_snfclean}{GEN d, GEN U, GEN V} assuming $d$, $U$, $V$ come
from \kbd{d = ZM\_snfall(x, \&U, \&V)}, where $U$ or $V$ may be \kbd{NULL},
cleans up the output in place. This means that elementary divisors equal to 1
are deleted and $U$, $V$ are updated. The output is not suitable for
\kbd{gerepileupto}.

The following 3 routines underly the various \tet{matrixqz} variants.
In all case the $m\times n$ \typ{MAT} $x$ is assumed to have rational
(\typ{INT} and \typ{FRAC}) coefficients

\fun{GEN}{QM_ImQ_hnf}{GEN x} returns an HNF basis for
$\text{Im}_\Q x \cap \Z^n$.

\fun{GEN}{QM_ImZ_hnf}{GEN x} returns an HNF basis for
$\text{Im}_\Z x \cap \Z^n$.

\fun{GEN}{QM_minors_coprime}{GEN x, GEN D}, assumes $m\geq n$, and returns
a matrix in $M_{m,n}(\Z)$ with the same $\Q$-image as $x$, such that
the GCD of all $n\times n$ minors is coprime to $D$; if $D$ is \kbd{NULL},
we want the GCD to be $1$.
\smallskip

The following routines are simple wrappers around the above ones and are
normally useless in library mode:

\fun{GEN}{hnf}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls \tet{ZM_hnf}.
Normally useless in library mode.

\fun{GEN}{hnfmod}{GEN x, GEN d} checks whether $x$ is a \kbd{ZM}, then calls
\tet{ZM_hnfmod}. Normally useless in library mode.

\fun{GEN}{hnfmodid}{GEN x,GEN d} checks whether $x$ is a \kbd{ZM}, then calls
\tet{ZM_hnfmodid}. Normally useless in library mode.

\fun{GEN}{hnfall}{GEN x} calls
\kbd{ZM\_hnfall(x, \&U, 1)} and returns $[H, U]$. Normally useless in library
mode.

\fun{GEN}{hnflll}{GEN x} calls \kbd{ZM\_hnflll(x, \&U, 1)} and returns $[H,
U]$. Normally useless in library mode.

\fun{GEN}{hnfperm}{GEN x} calls \kbd{ZM\_perm(x, \&U, \&P)} and returns $[H, U,
P]$. Normally useless in library mode.

\fun{GEN}{smith}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls
\kbd{ZM\_smith}. Normally useless in library mode.

\fun{GEN}{smithall}{GEN x} checks whether $x$ is a \kbd{ZM}, then calls
\kbd{ZM\_smithall(x, \&U, \&V)} and returns $[U,V,D]$. Normally useless in
library mode.

\subsec{The LLL algorithm}\sidx{LLL}

The basic GP functions and their immediate variants are normally not very
useful in library mode. We briefly list them here for completeness, see the
documentation of \kbd{qflll} and \kbd{qflllgram} for details:

\item \fun{GEN}{qflll0}{GEN x, long flag}

\fun{GEN}{lll}{GEN x} \fl = 0

\fun{GEN}{lllint}{GEN x} \fl = 1

\fun{GEN}{lllkerim}{GEN x} \fl = 4

\fun{GEN}{lllkerimgen}{GEN x} \fl = 5

\fun{GEN}{lllgen}{GEN x} \fl = 8

\item \fun{GEN}{qflllgram0}{GEN x, long flag}

\fun{GEN}{lllgram}{GEN x} \fl = 0

\fun{GEN}{lllgramint}{GEN x} \fl = 1

\fun{GEN}{lllgramkerim}{GEN x} \fl = 4

\fun{GEN}{lllgramkerimgen}{GEN x} \fl = 5

\fun{GEN}{lllgramgen}{GEN x} \fl = 8

\smallskip

The basic workhorse underlying all integral and floating point LLLs is

\fun{GEN}{ZM_lll}{GEN x, double D, long flag}, where $x$ is a \kbd{ZM};
$D \in ]1/4,1[$ is the Lov\'{a}sz constant determining the frequency of
swaps during the algorithm: a larger values means better guarantees for the
basis (in principle smaller basis vectors) but slower runtimes (suggested
value: $D = 0.99$).

\misctitle{Important:} This function does not collect garbage and its output
is not suitable for either \kbd{gerepile} or \kbd{gerepileupto}. We expect
the caller to do something simple with the output (e.g. matrix
multiplication), then collect garbage immediately.

\noindent\kbd{flag} is an or-ed combination of the following flags:

\item  \tet{LLL_GRAM}. If set, the input matrix $x$ is the Gram matrix ${}^t
v v$ of some lattice vectors $v$.

\item  \tet{LLL_INPLACE}. If unset, we return the base change matrix $U$,
otherwise the transformed matrix $x U$ or ${}^t U x U$ (\kbd{LLL\_GRAM}).
Implies \tet{LLL_IM} (see below).

\item  \tet{LLL_KEEP_FIRST}. The first vector in the output basis is the same
one as was originally input. Provided this is a shortest non-zero vector of
the lattice, the output basis is still LLL-reduced. This is used to reduce
maximal orders of number fields with respect to the $T_2$ quadratic form, to
ensure that the first vector in the output basis corresponds to $1$ (which is
a shortest vector).

The last three flags are mutually exclusive, either 0 or a single one must be
set:

\item  \tet{LLL_KER} If set, only return a kernel basis $K$ (not LLL-reduced).

\item  \tet{LLL_IM} If set, only return an LLL-reduced lattice basis $T$.
(This is implied by \tet{LLL_INPLACE}).

\item  \tet{LLL_ALL} If set, returns a 2-component vector $[K, T]$
corresponding to both kernel and image.


\fun{GEN}{lllfp}{GEN x, double D, long flag} is a variant for matrices
with inexact entries: $x$ is a matrix with real coefficients (types
\typ{INT}, \typ{FRAC} and \typ{REAL}), $D$ and $\fl$ are as in \tet{ZM_lll}.
The matrix is rescaled, rounded to nearest integers, then fed to
\kbd{ZM\_lll}. The flag \kbd{LLL\_INPLACE} is still accepted but less useful
(it returns an LLL-reduced basis associated to rounded input, instead of an
exact base change matrix).

\fun{GEN}{ZM_lll_norms}{GEN x, double D, long flag, GEN *ptB} slightly more
general version of \kbd{ZM\_lll}, setting \kbd{*ptB} to a vector containing
the squared norms of the Gram-Schmidt vectors $(b_i^*)$ associated to the
output basis $(b_i)$, $b_i^* = b_i + \sum_{j < i} \mu_{i,j} b_j^*$.


\fun{GEN}{lllintpartial_inplace}{GEN x} given a \kbd{ZM} $x$ of maximal rank,
returns a partially reduced basis $(b_i)$ for the space spanned by the
columns of $x$: $|b_i \pm b_j| \geq |b_i|$ for any two distinct basis vectors
$b_i$, $b_j$. This is faster than the LLL algorithm, but produces much larger
bases.

\fun{GEN}{lllintpartial}{GEN x} as \kbd{lllintpartial\_inplace}, but returns
the base change matrix $U$ from the canonical basis to the $b_i$, i.e. $x U$
is the output of \kbd{lllintpartial\_inplace}.

\subsec{Reduction modulo matrices}

\fun{GEN}{ZC_hnfremdiv}{GEN x, GEN y, GEN *Q} assuming $y$ is an
invertible \kbd{ZM} in HNF and $x$ is a \kbd{ZC}, returns the \kbd{ZC} $R$
equal to $x$ mod $y$ (whose $i$-th entry belongs to $[-y_{i,i}/2, y_{i,i}/2[$).
Stack clean \emph{unless} $x$ is already reduced (in which case, returns $x$
itself, not a copy). If $Q$ is not \kbd{NULL}, set it to the \kbd{ZC} such that
$x = yQ + R$.

\fun{GEN}{ZM_hnfremdiv}{GEN x, GEN y, GEN *Q} reduce
each column of the \kbd{ZM} $x$ using \kbd{ZC\_hnfremdiv}. If $Q$ is not
\kbd{NULL}, set it to the \kbd{ZM} such that $x = yQ + R$.

\fun{GEN}{ZC_hnfrem}{GEN x, GEN y} alias for \kbd{ZC\_hnfremdiv(x,y,NULL)}.

\fun{GEN}{ZM_hnfrem}{GEN x, GEN y} alias for \kbd{ZM\_hnfremdiv(x,y,NULL)}.

Besises the \emph{hnfrem} functions, which were specific to integral input,
we also have:

\fun{GEN}{reducemodinvertible}{GEN x, GEN y} $y$ is an invertible matrix
and $x$ a \typ{COL} or \typ{MAT} of compatible dimension.
Returns $x - y\lfloor y^{-1}x \rceil$, which has small entries and differs
from $x$ by an integral linear combination of the columns of $y$. Suitable
for \kbd{gerepileupto}, but does not collect garbage.

\fun{GEN}{closemodinvertible}{GEN x, GEN y} returns $x -
\kbd{reducemodinvertible}(x,y)$, i.e. an integral linear comination of
the columns of $y$, which is close to $x$.

\fun{GEN}{reducemodlll}{GEN x,GEN y} LLL-reduce the \kbd{ZM} $y$ and call
\kbd{reducemodinvertible} to find a small representative of $x$ mod $y \Z^n$.
Suitable for \kbd{gerepileupto}, but does not collect garbage.

