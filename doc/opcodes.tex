\documentclass[twoside,11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[french]{babel}

\usepackage{graphicx}
\usepackage{url}
\addtolength{\hoffset}{-2cm}
\addtolength{\textwidth}{4cm}
\addtolength{\voffset}{-1cm}
\addtolength{\textheight}{2cm}

\newcommand{\UnderscoreCommands}{\do\myMacro}
\newcommand{\myMacro}[1]{\includegraphics[scale=0.5]{#1}}
\usepackage[strings]{underscore}

\newcommand\define[2]{\section{#1}{\bf value=#2\par}}

\begin{document}

\title{GP opcodes}

\author{R\'emi Butel}

\maketitle

\define{OCpushlong}{A}
   push onto stack a long 'operand'; this long 'operand' can be the address of a GEN

   a lot of uses

\define{OCpushgen}{B}
   push onto stack a GEN from 'data' at place 'operand'

   for every string (CLOSUREs, ...)
   and in compilenode where Fconst for CSTint and CSTstr

\define{OCpushreal}{C}
   push onto stack a GEN t_REAL, with given precision, from a string taken in 'data' at place 'operand'

   in compilenode where Fconst for CSTreal

\define{OCpushstoi}{D}
   push onto stack an integer 'operand' converted in a GEN t_INT

   in compilenode where Fsmall

\define{OCpushvar}{E}
   create a varentrie as initial value if this entree has no initial value
   and push onto stack the initial value of an "entree" given by its address 'operand' (a pointer)

   in compilenode where Fconst for CSTquote (i.e. 'varname)

\define{OCpop}{F}
   pop 'operand' items

   in compilecast, when mode==Gvoid
   and in compilefunc when is_named "global" (dummy code)

\define{OCstoi}{G}
   change top of stack from integer to GEN; NO OPERAND

   if compilecast where mode==Ggen and type==Gsmall

\define{OCitos}{H}
   change top of stack from GEN to integer; NO OPERAND

   if compilecast where mode==Gsmall and type==Ggen

\define{OCtostr}{I}
   change top of stack by the string catenation of 'operand' popped from stack GEN values converted to their string representation

   in compilefunc, for r or s arguments

\define{OCvarn}{J}
   change top of stack by the number of variable of the assumed POL or SERIE top of stack

   if compilecast where mode==Gvar and type==Ggen

\define{OCcopy}{K}
   change top of stack by a copy of itself

   in compilenode where Ffacteurmat and !FLnocopy

\define{OCcopyifclone}{L}
   change top of stack by a copy of itself if isclone

   in compilenode where Faffect or Fentry

\define{OCprecreal}{M}
   push precreal; NO OPERAND

   in compilefunc, for PPauto

\define{OCprecdl}{N}
   push precdl (serie precision); NO OPERAND

   in compilefunc, for PPauto

\define{OCvec}{O}
   push onto stack a VEC of size 'operand'

   if compilenode where Fvec
   for compilevec, compilemat and compilefunc where PPstar

\define{OCmat}{P}
   push onto stack a COL of 'operand' columns of size top of stack (popped)

   in compilemat, for lines and columns

\define{OCcol}{Q}
   push onto stack a COL of size 'operand'

   for special case in compilefunc where OP == OPtrans and Fvec

\define{OCstackgen}{R}
   put in vector (at stack-2) at index 'operand' a copy of top of stack or top of stack if universal or inside bot..SUB_top;
   pop top of stack

   for compilevec, compilemat and compilefunc where PPstar

\define{OCcompo1}{S}
   if SUB_top of stack is VEC, COL, LIST or VECSMALL, and top of stack in its range, replace 2 top items of stack by SUB_top[top];
   in other words, replace 2 top items by element of listable SUB_top;
   'operand' is a mode (Ggen -> itself, Gsmall -> to integer, Gvar -> variable number, Gvoid -> void, Gvec -> invalid)

   in compilefacteurmat where Fmatrix and yy = -1 i.e. no y leaf of y leaf of n

\define{OCcompo2}{T}
   pop 3 items from stack (matrix, column, line), take an element in a t_MAT, push this element following mode given by operand

   in compilefacteurmat where Fmatrix

\define{OCcompoC}{U}
   pop 2 items from stack (matrix, index), take a column in a MATRIX, replace matrix by this column
   NO OPERAND

   in compilefacteurmat where FmatrixR

\define{OCcompoL}{V}
   pop 2 items from stack (matrix, index), take a line in a MATRIX, replace matrix by this line

   in compilefacteurmat where FmatrixL

\define{OCpushptr}{W}
   push onto stack a pointer towards the value 'x' of the pointer at top of stack "ptrs"; NO OPERAND

   in compilefunc, for *GEN arguments

\define{OCendptr}{X}
   for 'operand' times, change value in stack value of entry point or in "var" or in component for gp_pointer popped from "ptrs" stack with the value stored in this gp_pointer

   in compilefunc at the very end, if nbpointers

\define{OCcompo1ptr}{Y}
   from an index popped from stack, and a gp_pointer popped from "ptrs",
   replace pointer to element pointed by the matcomp part, if VEC, COL, VECSMALL or LIST, by pointer to element at this index
   update gp_pointer value
   NO OPERAND

   in compilevalue where Fmatrix and yy = -1 i.e. no y leaf of y leaf of n

\define{OCcompo2ptr}{Z}
   from two indices popped from stack, and a gp_pointer popped from "ptrs",
   replace pointer to element pointed by the matcomp part, if MAT, by pointer to element at these indices
   update gp_pointer value
   NO OPERAND

   in compilevalue where Fmatrix, or a special case for optimisation

\define{OCcompoCptr}{$[$}
   pop an index from stack, pop a gp_pointer from "ptrs" stack that must point to a MAT,
   replace pointed element by the column at index
   update gp_pointer value
   NO OPERAND

   in compilevalue where FmatrixR

\define{OCcompoLptr}{$\backslash$}
   pop an index from stack, pop a gp_pointer from "ptrs" stack that must point to a MAT,
   replace pointed element by the column at index
   update gp_pointer value
   NO OPERAND

   in compilevalue where FmatrixL

\define{OCcalllong}{$]$}
   "entree" is a function at address 'operand'; pop all arguments; evaluate; push result as a long

  in compilefunc, for general evaluations returning a long

\define{OCcallgen}{$\hat{ }$}
   "entree" is a function at address 'operand'; pop all arguments; evaluate; push result as a GEN

  in compilefunc, for M arguments (FIXME undocumented eval_mnemonic) and for general evaluations returning a GEN

\define{OCcallgen2}{\_}
   "entree" is a function at address 'operand'; pop all arguments; evaluate with 2 args; push result

  in compilefunc, for geval and for evaluations with 2 arguments returning a GEN

\define{OCcallint}{$`$}
   "entree" is a function at address 'operand'; pop all arguments; evaluate; push result as an int

  in compilefunc, for general evaluations returning an int

\define{OCcallvoid}{a}
   "entree" is a function at address 'operand'; pop all arguments; evaluate; no result

  in compilefunc, for general evaluations returning nothing

\define{OCcalluser}{b}
   pop t_CLOSURE from stack with 'operand' arguments; push arity-'operand' NULL arguments; evaluate function with all args; push result

\define{OCderivgen}{c}
   "entree" is a closure at address 'operand'; pop all arguments; push numerical derivative of entry

  in compilefunc, for general derivative evaluations returning a GEN

\define{OCderivuser}{d}
   pop t_CLOSURE from stack; push if necessary NULL arguments to reach function'arity; evaluate numerical derivative; push result

   in compileuserfunc and compilenode for Fcall

\define{OCnewframe}{e}
   increases "var" stack with 'operand' zero values

   in compilefunc, if there are arguments

\define{OCsaveframe}{f}
   save a "var" frame into top of stack CLOSURE word 6, length taken in "var" given from size of word 6

   in compilenode where Flambda

\define{OCpushdyn}{g}
   push onto stack the value of variable given by its address 'operand' (a pointer towards an "entree")

   in compileuserfunc
   in compilefunc, for global
   in compilenode, where Faffect of Fentry

\define{OCstoredyn}{h}
   pop from stack a value into value stack of "entree"' (AND REMOVE ITS OLD VALUE) at address 'operand' (a pointer)

   in compilefunc, for global
   in compilenode, where Faffect

\define{OCnewptrdyn}{i}
   create a new gp_pointer in "ptrs" from "entree" at address 'operand' (a pointer),
   put in this gp_pointer the GEN value of "entree" (created if new),
   initialize the matcomp part of this gp_pointer with a size 1 array containing this value
   do not change stack

   in compilefunc, for *GEN arguments; increment nbpointers

\define{OCsimpleptrdyn}{j}
   create a new gp_pointer in "ptrs" from "entree" at address 'operand' (a pointer),
   put in this gp_pointer the GEN value of "entree" (created if new),
   push onto stack this value

   in compilefunc, for *GEN arguments

\define{OCpushlex}{k}
   push onto stack a value from 'var' at s_var.n + 'operand'

   in compileuserfunc
   in compilenode, where Faffect of Fentry

\define{OCstorelex}{l}
   pop a value and store it in "var" for variable number 'operand'

   in compilefunc, for global
   in compilenode, where Faffect

\define{OCnewptrlex}{m}
   create a new gp_pointer in "ptrs" a fake "entree" for variable with number 'operand',
   put in this gp_pointer the GEN value of "var" at s_var.n + 'operand'
   initialize the matcomp part of this gp_pointer with a size 1 array containing this value
   do not change stack

   in compilefunc, for *GEN arguments; increment nbpointers

\define{OCsimpleptrlex}{n}
   create a new gp_pointer in "ptrs" for a fake "entree", for variable number 'operand',
   put in this gp_pointer the GEN value of "var" at s_var.n + 'operand'
   push onto stack this value

   in compilefunc, for *GEN arguments

\define{OCgetargs}{o}
   pop 'operand' arguments from stack to "var"
   executes in general a gclone or a gcopy of argument, even if argument is IN

   in compilenode where Flambda when there are arguments

\define{OCdefaultarg}{p}
   pop a closure from stack
   if 'operand' "var" flag is DEFAULT_VAL, evaluate closure and replace "var" value ar 'operand' by result

   in compilenode where Flambda

\define{OClocalvar}{q}
   create a local variable from an entry given by its address 'operand', pop value into "entree" stack value from stack

   if compilefunc if is_func_named("local")

\define{OClocalvar0}{r}
   create a local variable from an entry given by its address 'operand', zero initialisation
   NO OPERAND

   if compilefunc if is_func_named("local") and there is a y leaf

\end{document}
