\appendix{A Sample program and Makefile}

We assume that you have installed the PARI library and include files as
explained in Appendix A or in the installation guide. If you chose
differently any of the directory names, change them accordingly in the
Makefiles.

If the program example that we have given is in the file \kbd{matexp.c} (say
as the first of several matrix transcendental functions), then a sample
Makefile might look as follows. Note that the actual file
{\tt examples/Makefile} is much more elaborate and you should have a look at
it if you intend to use {\tt install()} on custom made functions, see
\secref{se:install}.

\bprog
CC = cc
INCDIR = \includedir
LIBDIR = \libdir
CFLAGS = -O -I\$(INCDIR) -L\$(LIBDIR)
\h
all:\qquad matexp
\h
matexp:\qquad	matexp.c
      \$(CC) \$(CFLAGS) -o matexp matexp.c -lpari -lm
\eprog

\noindent We then give the listing of the program \kbd{examples/matexp.c}
seen in detail in \secref{se:prog}, with the slight modifications explained
at the end of that section.
%
\bprog
\#include <pari.h>
\h
GEN
matexp(GEN x, long prec)
\obr
   long lx=lg(x),i,k,n, ltop = avma;
   GEN y,r,s,p1,p2;
\h
  /* {\rm check that x is a square matrix} */
  if (typ(x) != t\_MAT) err(typeer,"matexp");
  if (lx == 1) return cgetg(1, t\_MAT);
  if (lx != lg(x[1])) err(talker,"not a square matrix");
\h
  /* {\rm convert x to real or complex of real and compute its L2 norm} */
  s = gzero; r = cgetr(prec+1); gaffsg(1,r); x = gmul(r,x);
  for (i=1; i<lx; i++)
    s = gadd(s, gnorml2((GEN)x[i]));
  if (typ(s) == t\_REAL) setlg(s,3);
  s = gsqrt(s,3); /* {\rm we do not need much precision on s} */
\h
  /* {\rm if $\kbd{s}<1$ we are happy} */
  k = expo(s);
  if (k < 0) \obr n = 0; p1 = x; \cbr
  else \obr n = k+1; p1 = gmul2n(x,-n); setexpo(s,-1); \cbr
\h
  /* {\rm initializations before the loop} */
  y = gscalmat(r,lx-1); /* {\rm creates scalar matrix with r on diagonal} */
  p2 = p1; r = s; k = 1;
  y = gadd(y,p2);
\h
  /* {\rm now the main loop} */
  while (expo(r) >= -BITS\_IN\_LONG*(prec-1))
  \obr
    k++; p2 = gdivgs(gmul(p2,p1),k);
    r = gdivgs(gmul(s,r),k); y = gadd(y,p2);
  \cbr
\h
  /* {\rm now square back \kbd{n} times if necessary} */
  for (i=0; i<n; i++) y = gsqr(y);
  return gerepileupto(ltop,y);
\cbr
\h
int
main()
\obr
  long d, prec = 3;
  GEN x;
\h
  /* {\rm take a stack of 10MB, no prime table} */
  pari\_init(1000000,2);
  printf("precision of the computation in decimal digits:\bs n");
  d = itos(lisGEN(stdin));
  if (d > 0) prec = (long)(d*pariK1+3);
\h
  printf("input your matrix in GP format:\bs n");
  x = matexp(lisGEN(stdin), prec);
\h
  sor(x, 'g', d, 0);
  exit(0);
\cbr
\eprog\vfill\eject
