\def\TITLE{Developer's Guide to the PARI library}
\input parimacro.tex
\ifPDF % PDF output (from pdftex)
  \input pdfmacs.tex
\fi

% START TYPESET
\begintitle
\vskip 2.5truecm
\centerline{\mine Developer's Guide}
\vskip 1.truecm
\centerline{\mine to}
\vskip 1.truecm
\centerline{\mine the PARI library}
\vskip 1.truecm
\centerline{\sectiontitlebf (version \vers)}
\vskip 1.truecm
\authors
\endtitle

\copyrightpage
\tableofcontents
\openin\std=develop.aux
\ifeof\std
\else
  \input develop.aux
\fi
\chapno=0

\chapter{Work in progress}

This draft documents private internal functions and structures for hard-core
PARI developers. Anything in here is liable to change on short notice. Don't
use anything in the present document, unless you are implementing new
features for the PARI library. Try to fix the interfaces before using them,
or document them in a better way.
If you find an undocumented hack somewhere, add it here.

Hopefully, this will eventually document everything that we burried in
\kbd{paripriv.h} or even more private header files like \kbd{anal.h}.
Possibly, even implementation choices ! Way to go.

\section{Growarrays}

A \teb{growarray} is a container type, wich enlarges itself as one appends
elements to it. It has the following fields, accessed as \kbd{A->v},
\kbd{A->len}, \kbd{A->n}:

  \kbd{void **v}: an array of values, possibly from $0$ to
$\kbd{len}-1$, the ones from $0$ to $\kbd{n}-1$ being occupied. This array
is allocated using \kbd{malloc}, not on the PARI stack.

  \kbd{long len}: the number of cells allocated in \kbd{v}.

  \kbd{long n}: the number of occupied cells.

\noindent These containers are used when initializing the library, before the
PARI stack is available, hence allocate memory using \kbd{malloc}, not on
the stack. They are manipulated with the following functions.

\fun{void}{grow_init}{growarray A} initialize the \kbd{growarray} \kbd{A}.

\fun{void}{grow_append}{growarray A, void *e} append \kbd{e} to \kbd{A},
enlarging \kbd{A} if necessary.

\fun{void}{grow_copy}{growarray A, growarray B} creates a copy \kbd{B} of
\kbd{A}. Do not initialize \kbd{B} first (memory leak otherwise). If
\kbd{A} is \kbd{NULL}, this has the same effect as \kbd{grow\_init(B)}.

\fun{void}{grow_kill}{growarray A} frees \kbd{A}

\section{The type \typ{CLOSURE}}\kbdsidx{t_CLOSURE}\sidx{closure}
This type holds closures and functions in compiled form, so is deeply
linked to the internals of the GP compiler and evaluator.
The length of this type can be $5$, $6$ or $7$ depending whether the
object is an "inline closure", a "function" or a "true closure".

A function is a regular GP function.

A true closure is a GP function defined in a non-empty lexical context.

An inline closure is a closure that appears in the code without
the preceding \kbd{->} token. They are generally associated to the prototype
code 'E' and 'I'. Inline closures can only exist as data of other closures,
see below.

In the following example,
\bprog
f(a=Euler)=x->sin(x+a);
g=f(Pi/2);
plot(x=0,2*Pi,g(x))
@eprog

f is a function, g is a true closure and both "Euler" and "g(x)" are
inline closures.

This type has a second codeword \kbd{z[1]}, which is the arity of the
function or closure. This is zero for inline closures.

\item \kbd{z[2]} points to a \typ{STR} which hold the opcodes.

\item \kbd{z[3]} points to a \typ{VECSMALL} which hold the operands of the opcodes.

\item \kbd{z[4]} points to a \typ{VEC} which hold to the data referenced by the
\kbd{pushgen} opcodes, which can be \typ{CLOSURE}, and in particular
inline closures.

Additionnally, for functions and true closures,

\item \kbd{z[5]} points to a \typ{VEC} with two components which are \typ{STR}.
The first one displays the list of arguments of the closure without the
enclosing parentheses, the second one the GP code of the function at the
right of the \kbd{->} token. They are used to display the closure, either in
implicit or explicit form.

Additionnally, for true closure,

\item \kbd{z[6]} points to a \typ{VEC} which hold the values of all lexical
variables defined in the scope the closure was defined.

\section{The type \typ{LIST}}\kbdsidx{t_LIST}\sidx{list} This type need to go
through various hoops to support GP's inconvenient memory model. Don't
use \typ{LIST}s in pure library mode, reimplement ordinary lists! This
dynamic type is implemented by a \kbd{GEN} of length 3: two codewords and a
vector containing the actual entries. In a normal setup (a finished list,
ready to be used),

\item the vector is malloc'ed, so that it can be realloc'ated without moving
the parent \kbd{GEN}.

\item all the entries are clones, possibly with cloned subcomponents; they
must be deleted with \kbd{killbloc}, not \kbd{gunclone}.

The following macros are proper lvalues and access the components

\fun{long}{list_nmax}{GEN L}: current maximal number of elements. This grows
as needed.

\fun{GEN}{list_data}{GEN L}: the elements. If \kbd{v = list\_data(L)}, then
either \kbd{v} is \kbd{NULL} (empty list) or \kbd{l = lg(v)} is defined, and
the elements are \kbd{v[1]}, \dots, \kbd{v[l-1]}.

\typ{LIST} is not considered a recursive type, i.e.
\kbd{is\_recursive\_t(\typ{LIST})} is false. In most cases,
e.g.~\kbd{gerepile}, this means that the list components are not inspected
and a shallow copy of the malloced vector is made. \kbd{gcopy}, \kbd{gcone},
\kbd{copy\_bin\_canon} are exceptions, and make a full copy of the list.

The main problem with lists is to avoid memory leaks; in the above setup,
a statement like \kbd{a = List(1)} would already leak memory, since
\kbd{List(1)} allocates memory, which is cloned (second allocation) when
assigned to \kbd{a}; and the original list is lost. So,
when a \typ{LIST} is created viw \kbd{List} / \kbd{gtolist}, it is
created entirely on the stack, \emph{not} as described above. Such
a list is not yet proper and trying to append elements to it fails:
\bprog
? listput(List([1,2,3]),1)
  *** listput: store list in variable before appending elements.
@eprog\noindent
If we had been malloc'ing memory for the
\kbd{List([1,2,3])}, it would have leaked already. On the other hand, as soon
as this is copied, cloned, etc., the copy is a finished list as previously
described. In particular, assigning a list to a variable (or a component
thereof) ensures the assigned list is a proper one.

The following routine is a shortcut for \kbd{gcopy}:

\fun{GEN}{listcopy}{GEN L}: return a full copy of the \typ{LIST}~\kbd{L}.

A typical low-level construct:
\bprog
  long l;
  /* assume L is a t_LIST */
  L = list_data(L); /* discard t_LIST wrapper */
  l = L? lg(L): 1;
  for (i = 1; i < l; i++) output( gel(L, i) );
  for (i = 1; i < l; i++) gel(L, i) = gclone( ... );
@eprog\noindent

\section{Otherwise undocumented global variables}

\tet{PARI_SIGINT_block}: set this to a non-zero value if you want to block
the \kbd{SIGINT} signal in a critical part of your code. We use it
before calling \kbd{malloc}, \kbd{free} and such. (Because \kbd{SIGINT}
is non-fatal for us, and we don't want to leave the system stack in an
inconsistent state.)

\tet{PARI_SIGINT_pending}: if this is non-zero, then a \kbd{SIGINT} was
blocked. Take action as appropriate.

\section{Finite fields and black-box groups}

A black box group is defined by a \tet{bb_group} struct, describing methods
available to handle group elements:
\bprog
    struct bb_group
    {
      GEN (*mul)(void*, GEN, GEN);
      GEN (*pow)(void*, GEN, GEN);
      GEN (*rand)(void*);
      int (*cmp)(GEN, GEN);
      int (*cmp1)(GEN);
    };
@eprog
\kbd{mul(E,x,y)} returns the product $xy$.

\kbd{pow(E,x,n)} returns $x^n$ ($n$ integer, possibly negative or zero).

\kbd{rand(E)} returns a random element in the group.

\kbd{cmp(x,y)} implements a total ordering on the group elements
(return value $-1$, $0$ or $1$).

\kbd{cmp1(x)} returns zero if $x$ is not the neutral element in the group,
and a non-zero value otherwise.

A group is thus described by a \kbd{const bb\_struct} as above and auxiliary
data typecast to \kbd{void*}. The following functions operate on black-box
groups:

\fun{GEN}{gen_Shanks_log}{GEN x,GEN g,GEN N, void *E, const struct bb_group
*grp, GEN easy(void*E, GEN, GEN, GEN)} Generic baby-step/giant-step algorithm
(Shanks's method). Assuming that $g$ has order $N$, compute an integer $k$
such that $g^k = x$. This requires $O(\sqrt{N})$ group operations and uses an
auxilliary table containing $O(\sqrt{N})$ group elements.

\misctitle{FIXME:} could implement Floyd's cycle finding method to reduce to
$O(1)$ space.

If \kbd{easy} is not \kbd{NULL}, call \kbd{easy(E,a,g,N)} first and if the
return value is not \kbd{NULL}, return it. For instance this is used over
$\F_q^*$ to compute the discrete log of elements belonging to the prime
field.

\misctitle{FIXME:} more generally, one should compute the minimal polynomial
of $x$ and restrict to its field of definition.

\fun{GEN}{gen_Shanks_sqrtn}{GEN a, GEN n, GEN N, GEN *zetan, void *E, const
struct bb_group *grp} returns one solution of $x^n = a$ in a black-box cyclic
group of order $N$. Return \kbd{NULL} if no solution exists. If \kbd{zetan}
is not \kbd{NULL} it is set to an element of exact order $n$.

This function uses Shanks's baby-step giant step techniques for all prime
divisors of $\gcd(n,N)$.

\fun{GEN}{gen_PH_log}{GEN a, GEN g, GEN N, void *E, const struct bb_group *grp, GEN easy(void *E, GEN, GEN, GEN)}
Generic Pohlig-Helman algorithm. Assuming that $g$ has order $N$, compute
an integer $k$ such that $g^k = x$. This requires $O(p^{1/2+\epsilon})$ group
operations, where $p$ is the largest prime divisor of $N$, and uses an
auxiliary table containing $O(\sqrt{p})$ group elements.

\kbd{easy} is as in \kbd{gen\_Shanks\_log}.

\fun{GEN}{gen_eltorder}{GEN x, GEN N, void *E, const struct bb_group *grp}
computes the order of $x$. If $N$ is not \kbd{NULL} it is a multiple of the
order, as a \typ{INT} or a factorization matrix.

\vfill\eject
\input index\end
