This file lists the things that ought to be implemented / fixed. It is
hopelessly incomplete right now, but it's a start. Most items require major
work, and may not be that desireable after all. If you intend to work on
any of these things, have a look at CVS.txt and drop an email to pari-dev.

Priority classification (first column): [subjective and debatable!]
5    as soon as possible
4    should be done
3    nice to have
2    maybe not
1    probably not
0    no
-    unclassified

***************************   BUGS (general)     ****************************
Unless specified otherwise, examples assume 32bit machine and default precision 

5  bnfinit sometimes gives wrong answers because we cheat on the value of
Bach's bound, using B := 0.3 log^2 D by default, where 0.3 should really be 12
(under GRH), or some suitably optimized bound following Bach's article. If
the prime ideals of norm <= B do not generate the classgroup, we may not detect it, and compute junk. Ex:
 * setrand(3); bnfinit(y^4 + 1190*y^2 + 1416100).cyc --> [8,2,2,2].
   Wrong. The correct structure is [8,4,2].

 * setrand(1414185642); bnfinit(y^4 + 635*y^2 + 403225).reg is twice
the correct value.

 * setrand(867341586); bnfinit(y^4 - y^3 + 6122*y^2 + 6121*y + 37466641).gen
is wrong [second one is principal]. Group structure and regulator are correct!

5  polrootspadic(x^2+8*x+4, 2, 2) --> 2 + O(2^2), whereas there's no padic
   root. The documentation is not clear enough: should polrootspadic(x,p,r)
   find roots in Z/p^r [current behaviour], or use the precision of the
   supplied polynomial to compute roots in Qp, then return them at precision
   p^r [ better, polroots() and factorpadic() behave this way ] ?

5  polgalois(x^8-1864259299553450972214799899167226732549697977945716*x^6+331143259018657601105207922631212331088735421305543663274125986698777318014979969*x^4-2225286541902342283500014249183311190477390*x^2+5);
  ***   degree too large in tschirn.

5  intnum(x=0, Pi, sin(16*x)^2) --> 1e-54
   we evaluate at regularly spaced control points, interpolating the results
   obtained when increasing the number of points. When result looks stable,
   we stop. For some periodic function, this gives a ridiculous result.

4  precision problems in polgalois:
   setrand(7);
   polgalois(x^8+162644002617632464507038884216211529274267271168000002)
   gives wrong result at \p28 [32,-1,17], correct at \p38 [32,-1,15]

4  gcmp/gegal not transitive: [] == 0, [0] == 0, but [0] != []

3  many functions assume MAXVARN is a free variable, yielding bogus
   results if the input involves it (only affects library programming).

3  ellinit over Q_2 doesn't work (AGM loses too much precision)

3  ellpointtoz over Q_p makes no difference between P and -P (corrected over
   C by a cheap trick)

3  recursive plot easily fooled. One could split intervals in 3 + make sure
   size of neighbouring intervals don't differ too much.

***************************   BUGS (GP specific) ****************************

5  readline: assume a file 'foo' exists, \rf<TAB> --> \foo [\r f<TAB> is OK]

4  changing primelimit from within forprime loop yields unpredictable results

3  after allocatemem() / default(parisize, ...), the rest of the command is
   discarded (ends by a longjmp).

2  under GP after an error, memory is only recovered from "entire variables".
   Individual components of lists/vectors/matrices are left alone if the
   GLOBAL object wasn't modified during the last cycle (i.e only v[x] = ... 
   occured)

1  sum(i=1,3000, exp(-i^2)) --> overflow in R*R
   The "negligible" terms should be neglegted, not overflow because of the
   way the computation is done. [ Tough to correct! ]

***************************  DOCUMENTATION    ****************************

5  complete/update the tutorial (esp. section 11 and 12)

4  add examples for all functions in Chapter 3

4  separate chapter 4 and 5 and document the innards of PARI (entree,
   pariFILE, bloc ...)

2  HTML version (pod ? SGML ? yodl ???)

***************************  MISCELLANEOUS    ****************************

5  write decent (specialized) benches

3  switch to autoconf

3  use stat() instead of opendir() to check if a file is a directory.

***************************   ALGORITHMS      ****************************

Kernel:
=======
5  ensure consistent rounding in floating point operations. At least document
   it. Currently most routines truncate instead of rounding, most of the time.

5  check NaN in dbltor and related routines

5  implement Jebelean-Krandick diviiexact

5  implement Mulders/Hanrot-Zimmermann Karatsuba short product t_REAL * t_REAL

4  support standard rounding modes in floating point operations

4  benchmark / profile basic functions and see what needs to be done

4  inline level0 routines should operate on _limbs_, not on words.

4  use divide & conquer approach in string / integer conversions

3  FFT for basic types and polynomials (say in A[X], for A = Z, F_q, ...)

3  interval arithmetic

2  add support for different multiprecision kernels (a la LiDIA)

Misc:
=====
4  decent finite field package (remove all the nfxxxmodpr functions)

4  rnfkummer (non-prime degree)

4  nfsubfields [use known subfields to discard blocs right away] (current uses
   far too much memory)

3  zetak is very inefficient and unable to handle most fields of degree > 8

3  have quadclassunit return bnf structure

3  2-adic initell

3  p-adic ellztopoint

0  graphics: allow FIG output (besides PostScript) [easier to edit!]
   [ No: use pstoedit ]

***************************   LIBRARY DESIGN   ****************************

5  "PARI formats" have a %Z conversion character to print a GEN object. We
   should support  %m.nZ, %0nZ, %-nZ, etc. with standard meanings.

5  add (printf-style) library functions corresponding to GP routines print*

4  a system of DEBUGLEVEL classes [e.g \g 5 "LLL" ] (such that the user can
   easily define new ones)

4  allow generic functions to process and produce t_SMALL's

4  remove all dependences on types ordering [if (typ(x) < t_POL) ...]

3  remove global variables gpi, geuler: their precision is unpredictable
   (at least as much as requested in last const[pi|euler](), possibly much
   more). Explicit call to mp[pi|euler] should be required. Will break
   existing code...

3  rename library functions following GP names

3  rewrite the generic functions (gadd/gmul/gdiv plus a couple of others) to
   use (two-dimensional) table lookups instead of switches

3  introduce "special" types for objects which are really containers and
   should be defined by a secondary type (e.g number fields, finite fields,
   p-adic fields, elliptic curves, ...). Would keep list of types small
   (and fast)

3  better representations for multivariate polynomials

3  type "element in" ([number|finite] field...), "point" on elliptic curve

3  find a way to deal (generically) with "integral object + its content"
   Application (e.g): fractional ideals much more efficient.

2  "mute" variables for t_POLMOD. Should have Mod(x,x^2+1) == Mod(y,y^2+1).

2  have some header magic (transparently) prepend some prefix (e.g "pari_")
   before all exported functions to prevent name conflicts. Build alias
   files for debuggers

***************************   GP DESIGN       ****************************

-  rework the semantics of "trap". 

-  Allow GP to trap an OS signal. A good example. Suppose that gp runs, say
   in nohup mode, and it takes several days or even weeks to complete the
   program. In meantime several things can happen resulting in shutdown of
   the machine. On shutdown all programs receive SIGTERM signal. I would like
   gp to be able to trap this signal and when it receives one, to execute
   some gp command, e.g saving all settings with full accuracy (e.g writebin).

5  add a printf command: simple interface to pariputsf allowing only %Z
   conversion characters  (see related entry in LIBRARY DESIGN section)

5  remove limitation to 8 arguments for static functions (argvec[9])

4  extend forprime(n=a,b,...) so that b can go over primelimit [cut [a,b]
   in large intervals, sieve out multiple of small primes there, then use
   isprime() on the rest]

3  changevar with explicit (incomplete) permutation. E.g
   changevar(p, [x,y], [a,b]) for x -> a, y -> b
   add a flag to substitute in succession or in parallel (e.g if a involves y)

3  possibility to save and load a session (variables, functions, defaults)

3  a type t_FILE [current: stream re-opened/flushed/closed after every single
   write(): disaster when one wants to write often to the same file]

3  add a possibility to increase the maximal recursion depth (need to 
   increase the GP process stack: use setrlimit(RLIMIT_STACK,) + fork)

***************************   TOOLS           ****************************

4  a script converting prototype to parser code (e.g GEN f(GEN,GEN) --> "GG")

3  a script to translate "legacy" GP code into something using GP2 function
   names

3  write an analog of the 'echo' default which would print code as it is
   executed, not as it is read

2  write a GP scripts debugger

2  write a GP scripts profiler
